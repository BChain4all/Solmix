import { BasePrinter } from "./base.js";
export class PrinterMeta extends BasePrinter {
  printDataLocation = ({ node }) => node.name;
  printIdentifierPath = ({ path, print }) => this.builders.join(this.dot, path.map(print, "identifiers"));
  printImportAliases = ({ node, path, print }) => {
    const parts = [path.call(print, "foreign")];
    if (node.local)
      parts.push(this.space, "as", this.space, path.call(print, "local"));
    return parts;
  };
  printImportDirective = ({ node, path, print }) => {
    let result = "";
    const importPath = path.call(print, "path");
    if (node.unitAlias) {
      const unitAlias = path.call(print, "unitAlias");
      if (node.importAll) {
        result = this.builders.join(this.space, [
          "import",
          "*",
          "as",
          unitAlias,
          "from",
          importPath
        ]);
      } else {
        result = this.builders.join(this.space, ["import", importPath, "as", unitAlias]);
      }
    } else if (node.symbolAliases.length) {
      result = this.builders.join(this.space, [
        "import",
        this.block(this.paramater(path.map(print, "symbolAliases"))),
        "from",
        importPath
      ]);
    } else {
      result = this.builders.join(this.space, ["import", importPath]);
    }
    return [result, this.semi];
  };
  printInheritanceSpecifier = ({ node, path, print }) => {
    const parts = [path.call(print, "baseName")];
    if (node.arguments !== null) {
      const paramater = this.paramater(path.map(print, "arguments"));
      parts.push(this.tuple(paramater));
    }
    return parts;
  };
  printModifierInvocation = ({ node, path, print }) => {
    const name = path.call(print, "name");
    if (node.arguments === null)
      return name;
    return this.builders.group([name, this.tuple(this.paramater(path.map(print, "arguments")))]);
  };
  printPath = ({ node }) => this.literal(node.name);
  printPragmaDirective = ({ node }) => {
    const groupId = Symbol("pragma");
    const line = this.builders.indentIfBreak(this.builders.line, { groupId });
    const literal = this.builders.join(line, node.literals);
    return this.builders.group(["pragma", line, literal, this.semi], { id: groupId });
  };
  printSourceUnit = ({ path, print }) => {
    const contents = [];
    path.map((nodePath) => {
      contents.push(nodePath.call(print));
      contents.push(this.builders.hardline);
      if (nodePath.node?.type !== nodePath.next?.type || nodePath.next?.type === "ContractDefinition") {
        contents.push(this.builders.hardline);
      }
    }, "nodes");
    return contents;
  };
  printUsingAliases = ({ node, path, print }) => {
    const parts = [path.call(print, "name")];
    if (node.operator !== null)
      parts.push(this.space, "as", this.space, path.call(print, "operator"));
    return parts;
  };
  printUsingDirective = ({ node, path, print }) => {
    const content = [this.space];
    if (node.usingAliases !== null && node.usingAliases.length) {
      content.push(this.block(this.paramater(path.map(print, "usingAliases"))));
    } else {
      content.push(path.call(print, "libraryName"));
    }
    const typeName = node.typeName === "*" ? "*" : path.call(print, "typeName");
    const globalFlag = node.global ? [this.space, "global"] : "";
    return ["using", content, this.space, "for", this.space, typeName, globalFlag, this.semi];
  };
}
