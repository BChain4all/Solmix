import * as ast from '../../ast';
import { type AstPath, type Doc, type ParserOptions, doc } from 'prettier';
import { SyntaxTokenType, SyntaxToken } from '../../parser';
export { Doc };
export type CommentToken = SyntaxToken & {
    placement: 'remaining' | 'ownLine' | 'endOfLine';
    leading: boolean;
    trailing: boolean;
    printed: boolean;
    nodeDescription: string;
};
export type WithComments<T extends ast.SyntaxNode = ast.SyntaxNode> = T & {
    comments?: CommentToken[];
};
export type PrintFunc<T extends ast.SyntaxNode = ast.SyntaxNode> = (arg: {
    node: WithComments<T>;
    path: AstPath<WithComments<T>>;
    options: ParserOptions<WithComments<T>>;
    print: (path: AstPath<WithComments | null>) => Doc;
    args?: any;
}) => Doc;
export declare const lineComments: SyntaxTokenType[];
export declare const blockComments: SyntaxTokenType[];
export declare const comments: SyntaxTokenType[];
export declare class BasePrinter {
    readonly options: ParserOptions<WithComments>;
    readonly print: (path: AstPath<any>) => Doc;
    readonly space = " ";
    readonly dot = ".";
    readonly comma = ",";
    readonly semi = ";";
    readonly quote = "\"";
    readonly singleQuote = "'";
    readonly builders: typeof doc.builders;
    constructor(options: ParserOptions<WithComments>, print: (path: AstPath<any>) => Doc);
    pangu: (path: AstPath<any>) => "" | doc.builders.Hardline;
    literal: (value: Doc) => doc.builders.Doc[];
    block: (value: Doc, empty?: boolean) => string[] | doc.builders.Group;
    paramater: (value: Doc[], sep?: Doc) => doc.builders.Doc[];
    tuple: (value: Doc, groupId?: symbol) => doc.builders.Group;
    list: (value: Doc, groupId?: symbol) => doc.builders.Group;
}
