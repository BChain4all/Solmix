import { BasePrinter } from "./base.js";
export class PrinterYul extends BasePrinter {
  printYulAssignment = ({ path, print }) => {
    return [
      this.paramater(path.map(print, "paths")),
      this.space,
      ":=",
      this.space,
      path.call(print, "expression")
    ];
  };
  printYulBlock = ({ node, path, print }) => {
    const statements = path.map((p) => [print(p), this.pangu(p)], "statements");
    return this.block(
      this.builders.join(this.builders.line, statements),
      !node.statements.length
    );
  };
  printYulBoolean = ({ node }) => node.name;
  printYulForStatement = ({ path, print }) => {
    const forConditions = [
      this.builders.line,
      path.call(print, "initializationBlock"),
      this.builders.line,
      path.call(print, "conditionExpression"),
      this.builders.line,
      path.call(print, "loopBlock")
    ];
    return this.builders.group([
      "for",
      this.builders.ifBreak(this.builders.indent(forConditions), forConditions),
      this.builders.line,
      path.call(print, "body")
    ]);
  };
  printYulFunctionCall = ({ path, print, node }) => {
    return [node.identifier, this.tuple(this.paramater(path.map(print, "expressions")))];
  };
  printYulFunctionDefinition = ({ node, path, print }) => {
    const parts = [
      "function",
      this.space,
      node.name,
      this.tuple(this.paramater(node.parameters)),
      this.space,
      "->",
      this.space,
      this.paramater(node.returnParameters),
      this.space,
      path.call(print, "body")
    ];
    return this.builders.group(parts);
  };
  printYulIfStatement = ({ path, print }) => {
    return ["if", this.space, path.call(print, "condition"), this.space, path.call(print, "body")];
  };
  printYulLiteral = ({ node }) => node.name;
  printYulPath = ({ node }) => node.name;
  printYulStatement = ({ node, path, print }) => {
    const parts = [];
    if (typeof node.expression === "string") {
      parts.push(node.expression);
    } else if (node.expression !== null) {
      parts.push(path.call(print, "expression"));
    }
    if (parts.length)
      parts.push(this.builders.breakParent);
    return this.builders.group(parts);
  };
  printYulSwitchCase = ({ path, print }) => {
    return ["case", this.space, path.call(print, "case"), this.space, path.call(print, "body")];
  };
  printYulSwitchStatement = ({ node, path, print }) => {
    const parts = ["switch", this.space, path.call(print, "expression")];
    path.map((p) => {
      parts.push(this.space, print(p));
    }, "switchCases");
    if (node.default && node.body !== null) {
      parts.push(this.space, "default", this.space, path.call(print, "body"));
    }
    return this.builders.group(parts);
  };
  printYulVariableDeclaration = ({ node, path, print }) => {
    const parts = ["let"];
    parts.push(this.space, this.paramater(node.identifiers));
    if (node.expression !== null) {
      parts.push(this.space, ":=", this.space, path.call(print, "expression"));
    }
    return this.builders.group(parts);
  };
}
