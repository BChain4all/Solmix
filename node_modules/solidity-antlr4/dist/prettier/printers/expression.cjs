"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrinterExpression = void 0;
var _base = require("./base.cjs");
class PrinterExpression extends _base.BasePrinter {
  printAssignOp = ({
    node
  }) => node.name;
  printBinaryOperation = ({
    node,
    path,
    print
  }) => {
    const parts = [];
    if (node.left !== null) parts.push(path.call(print, "left"));
    if (node.operator !== null) parts.push(this.space, node.operator);
    if (node.right !== null) parts.push(this.builders.line, path.call(print, "right"));
    return this.builders.group(parts);
  };
  printAssignment = ({
    node,
    path,
    print
  }) => {
    const parts = [];
    if (node.left !== null) parts.push(path.call(print, "left"));
    if (node.operator !== null) parts.push(this.space, node.operator);
    if (node.right !== null) parts.push(this.builders.line, path.call(print, "right"));
    return this.builders.group(parts);
  };
  printBooleanLiteral = ({
    node
  }) => node.value === true ? "true" : "false";
  printConditional = ({
    path,
    print
  }) => {
    const groupId = Symbol("conditional");
    const breakLine = this.builders.indentIfBreak(this.builders.line, {
      groupId
    });
    return this.builders.group([path.call(print, "condition"), breakLine, "?", breakLine, path.call(print, "trueExpression"), breakLine, ":", breakLine, path.call(print, "falseExpression")], {
      id: groupId
    });
  };
  printFunctionCallOptions = ({
    path,
    print
  }) => {
    return [path.call(print, "expression"), this.block(this.paramater(path.map(print, "arguments")))];
  };
  printFunctionCall = ({
    path,
    print
  }) => {
    return [path.call(print, "expression"), this.tuple(this.paramater(path.map(print, "arguments")))];
  };
  printHexStringLiteral = ({
    node
  }) => ["hex", this.literal(node.value)];
  printIdentifier = ({
    node
  }) => node.name;
  printIndexAccess = ({
    node,
    path,
    print
  }) => {
    return [path.call(print, "baseExpression"), this.list(node.indexExpression ? path.call(print, "indexExpression") : "")];
  };
  printIndexRangeAccess = ({
    path,
    print
  }) => {
    const inner = [path.call(print, "startExpression"), ":", path.call(print, "endExpression")];
    return [path.call(print, "baseExpression"), this.list(inner)];
  };
  printInlineArray = ({
    path,
    print
  }) => {
    return this.list(this.paramater(path.map(print, "expressions")));
  };
  printMemberAccess = ({
    node,
    path,
    print
  }) => {
    return [path.call(print, "expression"), this.dot, node.memberName];
  };
  printMetaType = ({
    path,
    print
  }) => {
    return ["type", "(", path.call(print, "typeName"), ")"];
  };
  printNamedArgument = ({
    path,
    print
  }) => {
    return [path.call(print, "name"), ":", this.space, path.call(print, "expression")];
  };
  printNewExpr = ({
    path,
    print
  }) => {
    return ["new", this.space, path.call(print, "typeName")];
  };
  printNumberLiteral = ({
    node
  }) => {
    if (node.hexValue !== null) return node.hexValue;
    const parts = [node.value];
    if (node.subDenomination !== null) parts.push(node.subDenomination);
    return parts;
  };
  printPayableConversion = ({
    path,
    print
  }) => {
    return ["payable", this.tuple(this.paramater(path.map(print, "arguments")))];
  };
  printStringLiteral = ({
    node
  }) => this.literal(node.value);
  printTupleExpression = ({
    path,
    print
  }) => {
    return this.tuple(this.paramater(path.map(print, "expressions")));
  };
  printUnaryOperation = ({
    node,
    path,
    print
  }) => {
    const parts = [];
    if (node.left !== null) parts.push(path.call(print, "left"));
    if (node.operator !== null) parts.push(node.operator);
    if (node.operator === "delete") parts.push(this.space);
    if (node.right !== null) parts.push(path.call(print, "right"));
    return this.space, parts;
  };
  printUnicodeStringLiteral = ({
    node
  }) => ["unicode", this.literal(node.value)];
  printUserDefinableOperator = ({
    node
  }) => node.name;
}
exports.PrinterExpression = PrinterExpression;