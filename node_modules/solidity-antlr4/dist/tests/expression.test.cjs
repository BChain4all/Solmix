"use strict";

var _utils = require("./utils.test.cjs");
var _vitest = require("vitest");
(0, _vitest.test)("named-argument", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.callArgumentList())(`({value: msg.value, bar: hex"aabb"})`)).toMatchObject([{
    type: "NamedArgument",
    name: "value",
    expression: {
      type: "MemberAccess",
      expression: "msg",
      memberName: "value"
    }
  }, {
    type: "NamedArgument",
    name: "bar",
    expression: {
      value: "aabb"
    }
  }]);
});
(0, _vitest.test)("literal", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.tupleExpression())(`(1, 0x1, 1 ether, "address", "", true, hex"ffff", unicode"\u{1F603}")`)).toMatchObject({
    expressions: [{
      type: "NumberLiteral",
      value: "1"
    }, {
      type: "NumberLiteral",
      hexValue: "0x1"
    }, {
      type: "NumberLiteral",
      value: "1",
      subDenomination: "ether"
    }, {
      type: "StringLiteral",
      value: "address"
    }, {
      type: "StringLiteral",
      value: ""
    }, {
      type: "BooleanLiteral",
      value: true
    }, {
      type: "HexStringLiteral",
      value: "ffff"
    }, {
      type: "UnicodeStringLiteral",
      value: "\u{1F603}"
    }]
  });
});
(0, _vitest.test)("assignment", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.tupleExpression())(`(a += b, a++, delete b, foo ? x : 2)`)).toMatchObject({
    expressions: [{
      left: "a",
      right: "b",
      operator: "+="
    }, {
      operator: "++",
      left: "a"
    }, {
      operator: "delete",
      right: "b"
    }, {
      condition: "foo",
      trueExpression: "x",
      falseExpression: {
        value: "2"
      }
    }]
  });
});
(0, _vitest.test)("memberAccess", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.tupleExpression())(`(msg.value, foo.address)`)).toMatchObject({
    expressions: [{
      expression: "msg",
      memberName: "value"
    }, {
      expression: "foo",
      memberName: "address"
    }]
  });
});
(0, _vitest.test)("expression", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.tupleExpression())(`(call{foo: bar}, obj({foo: bar}), payable({foo: bar}), type(address), new Foo)`)).toMatchObject({
    expressions: [{
      expression: "call",
      arguments: [{
        name: "foo",
        expression: "bar"
      }]
    }, {
      expression: "obj",
      arguments: [{
        name: "foo",
        expression: "bar"
      }]
    }, {
      arguments: [{
        name: "foo",
        expression: "bar"
      }]
    }, {
      typeName: "address"
    }, {
      typeName: "Foo"
    }]
  });
});
(0, _vitest.test)("indexAccess", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.tupleExpression())(`(arr[0], arr[:10], arr[10:], arr[0:10])`)).toMatchObject({
    expressions: [{
      baseExpression: "arr",
      indexExpression: {
        value: "0"
      }
    }, {
      baseExpression: "arr",
      startExpression: null,
      endExpression: {
        value: "10"
      }
    }, {
      baseExpression: "arr",
      startExpression: {
        value: "10"
      },
      endExpression: null
    }, {
      baseExpression: "arr",
      startExpression: {
        value: "0"
      },
      endExpression: {
        value: "10"
      }
    }]
  });
});