"use strict";

var _utils = require("./utils.test.cjs");
var _vitest = require("vitest");
(0, _vitest.test)("variableDeclaration", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.variableDeclaration())(`address memory user`)).toMatchObject({
    name: "user",
    dataLocation: "memory",
    typeName: "address"
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.parameterDeclaration())(`address memory user`)).toMatchObject({
    name: "user",
    dataLocation: "memory",
    typeName: "address"
  });
});
(0, _vitest.test)("stateVariableDeclaration", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.stateVariableDeclaration())(`uint internal immutable override(Foo) amount = 1;`)).toMatchObject({
    name: "amount",
    typeName: "uint",
    internal: true,
    immutable: true,
    override: ["Foo"],
    expression: {
      value: "1"
    }
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.stateVariableDeclaration())(`uint public constant amount = 2;`)).toMatchObject({
    name: "amount",
    typeName: "uint",
    public: true,
    constant: true,
    override: null,
    expression: {
      value: "2"
    }
  });
});
(0, _vitest.test)("constantVariableDeclaration", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.constantVariableDeclaration())(`uint128 constant amount = 100;`)).toMatchObject({
    name: "amount",
    typeName: "uint128"
  });
});
(0, _vitest.test)("libraryDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.libraryDefinition())(`library Foo { address name; }`)).toMatchObject({
    type: "ContractDefinition",
    contractKind: "library",
    name: "Foo",
    nodes: [{
      type: "VariableDeclaration"
    }]
  });
});
(0, _vitest.test)("interfaceDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.interfaceDefinition())(`interface Foo { address name; }`)).toMatchObject({
    type: "ContractDefinition",
    contractKind: "interface",
    name: "Foo",
    nodes: [{
      type: "VariableDeclaration"
    }]
  });
});
(0, _vitest.test)("contractDefinition", () => {
  const pContract = (0, _utils.createParse)(p => p.contractDefinition());
  (0, _vitest.expect)(pContract(`contract Foo { address name; }`)).toMatchObject({
    type: "ContractDefinition",
    contractKind: "contract",
    name: "Foo",
    abstract: false,
    nodes: [{
      type: "VariableDeclaration"
    }]
  });
  (0, _vitest.expect)(pContract(`contract Foo { address name; }`)).toMatchObject({
    name: "Foo",
    contractKind: "contract",
    abstract: false,
    nodes: [{
      type: "VariableDeclaration"
    }]
  });
  (0, _vitest.expect)(pContract(`abstract contract Bar { }`)).toMatchObject({
    name: "Bar",
    contractKind: "contract",
    abstract: true,
    nodes: []
  });
  (0, _vitest.expect)(pContract(`contract Foo is X, Y.Z(100) { }`)).toMatchObject({
    name: "Foo",
    contractKind: "contract",
    baseContracts: [{
      baseName: "X"
    }, {
      baseName: "Y.Z"
    }]
  });
});
(0, _vitest.test)("enumDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.enumDefinition())(`enum TokenType { Fungible, NonFungible }`)).toMatchObject({
    name: "TokenType",
    members: ["Fungible", "NonFungible"]
  });
});
(0, _vitest.test)("errorDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.errorDefinition())(`error MyError(address, uint amount);`)).toMatchObject({
    name: "MyError",
    parameters: [{
      typeName: "address"
    }, {
      typeName: "uint",
      name: "amount"
    }]
  });
});
(0, _vitest.test)("eventDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.eventDefinition())(`event Transfer() anonymous;`)).toMatchObject({
    name: "Transfer",
    anonymous: true
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.eventDefinition())(`event Transfer(address, uint indexed amount);`)).toMatchObject({
    name: "Transfer",
    parameters: [{
      indexed: false,
      typeName: "address"
    }, {
      indexed: true,
      typeName: "uint",
      name: "amount"
    }]
  });
});
(0, _vitest.test)("functionDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.functionDefinition())(`function transfer(address calldata recipient, uint256 amount) public virtual override(Foo, Bar) onlyAdmin returns (bool) {}`)).toMatchObject({
    name: "transfer",
    functionKind: "function",
    override: ["Foo", "Bar"],
    virtual: true,
    visibility: "public",
    stateMutability: null,
    modifiers: [{
      name: "onlyAdmin"
    }],
    returnParameters: [{
      typeName: "bool"
    }],
    parameters: [{
      name: "recipient",
      typeName: "address",
      dataLocation: "calldata"
    }, {
      name: "amount",
      typeName: "uint256"
    }],
    body: {}
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.contractDefinition().contractBodyElement(0).constructorDefinition())(`contract F { constructor(string memory _name, string memory _text) X(_name) Y(_text) {} }`)).toMatchObject({
    name: null,
    functionKind: "constructor",
    override: null,
    virtual: false,
    visibility: null,
    stateMutability: "payable",
    modifiers: [{
      name: "X"
    }, {
      name: "Y"
    }],
    parameters: [{
      name: "_name",
      dataLocation: "memory",
      typeName: "string"
    }, {
      name: "_text",
      dataLocation: "memory",
      typeName: "string"
    }]
  });
});
(0, _vitest.test)("modifierDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.modifierDefinition())(`modifier onlyAdmin(address sender) virtual override(Foo, Bar) {}`)).toMatchObject({
    name: "onlyAdmin",
    override: ["Foo", "Bar"],
    virtual: true,
    parameters: [{
      name: "sender",
      typeName: "address"
    }],
    body: {}
  });
});
(0, _vitest.test)("userDefinedValueTypeDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.userDefinedValueTypeDefinition())(`type Foo is uint256;`)).toMatchObject({
    name: "Foo",
    typeName: "uint256"
  });
});
(0, _vitest.test)("variableDeclarationTuple", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.variableDeclarationTuple())(`(address calldata user, uint256 amount)`)).toMatchObject([{
    name: "user",
    typeName: "address",
    dataLocation: "calldata"
  }, {
    name: "amount",
    typeName: "uint256"
  }]);
});
(0, _vitest.test)("structDefinition", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.structDefinition())(`struct Coin { string obverse; string reverse; }`)).toMatchObject({
    name: "Coin",
    members: [{
      name: "obverse",
      typeName: "string"
    }, {
      name: "reverse",
      typeName: "string"
    }]
  });
});