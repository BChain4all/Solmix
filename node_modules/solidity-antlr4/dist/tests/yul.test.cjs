"use strict";

var _utils = require("./utils.test.cjs");
var _vitest = require("vitest");
(0, _vitest.test)("assemblyStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { let x := 123 }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulVariableDeclaration",
        identifiers: ["x"]
      }
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { f.b, foo, bar := mul(x, y) }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulAssignment",
        paths: ["f.b", "foo", "bar"]
      }
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { mul(x, y) }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulFunctionCall",
        identifier: "mul",
        expressions: ["x", "y"]
      }
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { if foo {} }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulIfStatement",
        condition: "foo",
        body: {}
      }
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { for {} bar {} {} }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulForStatement",
        initializationBlock: {},
        conditionExpression: "bar",
        loopBlock: {},
        body: {}
      }
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { leave break continue }`)).toMatchObject({
    yulStatements: [{
      expression: "leave"
    }, {
      expression: "break"
    }, {
      expression: "continue"
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { switch x case 0 {} default {} }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulSwitchStatement",
        expression: "x",
        switchCases: [{
          case: "0"
        }],
        default: true,
        body: {}
      }
    }]
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly { function foo(x, y) -> a, b {} }`)).toMatchObject({
    yulStatements: [{
      expression: {
        type: "YulFunctionDefinition",
        name: "foo",
        parameters: ["x", "y"],
        returnParameters: ["a", "b"],
        body: {}
      }
    }]
  });
});