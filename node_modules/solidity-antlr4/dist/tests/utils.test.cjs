"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visitor = exports.parse = exports.format = exports.createParse = exports.createLog = void 0;
var _antlr = require("../antlr4/index.cjs");
var _builder = require("../ast/builder.cjs");
var _traverse = require("../traverse/index.cjs");
var _base = require("../ast/base.cjs");
var _vitest = require("vitest");
const format = ast => (0, _traverse.serialize)(ast, p => {
  if (p.node instanceof _base.BaseNodeString) return p.node.name;
  return p.node;
});
exports.format = format;
const parse = (input, callback = p => p.sourceUnit(), afterParse = format) => {
  const lexer = new _antlr.SolidityLexer(_antlr.CharStreams.fromString(input));
  const parser = new _antlr.SolidityParser(new _antlr.CommonTokenStream(lexer));
  const tree = callback(parser);
  const ast = tree.accept(_builder.solidityASTBuilder);
  return afterParse(ast);
};
exports.parse = parse;
const createParse = (callback = p => p.sourceUnit(), afterParse = format) => {
  return input => parse(input, callback, afterParse);
};
exports.createParse = createParse;
const createLog = (callback = p => p.sourceUnit()) => {
  return input => parse(input, callback, ast => {
    const newAST = (0, _traverse.serialize)(ast, p => {
      if (p.node instanceof _base.BaseNodeString) {
        return p.node.name;
      }
      return p.node;
    });
    console.log(newAST);
    return newAST;
  });
};
exports.createLog = createLog;
const visitor = exports.visitor = _builder.solidityASTBuilder;
(0, _vitest.test)("utils", () => {});