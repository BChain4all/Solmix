"use strict";

var _utils = require("./utils.test.cjs");
var _vitest = require("vitest");
(0, _vitest.test)("ifStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.ifStatement())(`if (foo) {} else if (bar) {} else {}`)).toMatchObject({
    condition: "foo",
    ifStatement: {},
    elseStatement: {
      condition: "bar",
      ifStatement: {},
      elseStatement: {}
    }
  });
});
(0, _vitest.test)("revertStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.revertStatement())(`revert Foo(name);`)).toMatchObject({
    expression: "Foo",
    arguments: ["name"]
  });
});
(0, _vitest.test)("returnStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.returnStatement())(`return name;`)).toMatchObject({
    expression: "name"
  });
});
(0, _vitest.test)("emitStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.emitStatement())(`emit Transfer(name);`)).toMatchObject({
    expression: "Transfer",
    arguments: ["name"]
  });
});
(0, _vitest.test)("assemblyStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.assemblyStatement())(`assembly "evmasm" ("foo", "bar") {}`)).toMatchObject({
    flags: ["foo", "bar"],
    dialect: "evmasm"
  });
});
(0, _vitest.test)("tryStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.tryStatement())(`try new Foo(owner) returns (Foo foo) {} catch Error(string memory reason) {} catch (bytes memory reason) {}`)).toMatchObject({
    expression: {
      expression: {
        typeName: "Foo"
      },
      arguments: ["owner"]
    },
    returnParameters: [{
      name: "foo",
      typeName: "Foo"
    }],
    body: {},
    catchClauses: [{
      errorName: "Error",
      parameters: [{
        name: "reason",
        typeName: "string",
        dataLocation: "memory"
      }],
      body: {}
    }, {
      parameters: [{
        name: "reason",
        typeName: "bytes",
        dataLocation: "memory"
      }],
      body: {}
    }]
  });
});
(0, _vitest.test)("whileStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.whileStatement())(`while (foo) {}`)).toMatchObject({
    condition: "foo"
  });
  (0, _vitest.expect)((0, _utils.createParse)(p => p.doWhileStatement())(`do {} while (foo);`)).toMatchObject({
    condition: "foo"
  });
});
(0, _vitest.test)("forStatement", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.forStatement())(`for (uint i = 0; i < 10; i++) {}`)).toMatchObject({
    initializationExpression: {
      type: "VariableDeclarationStatement"
    },
    conditionExpression: {
      expression: {
        operator: "<",
        left: "i",
        right: {
          value: "10"
        }
      }
    },
    loopExpression: {
      operator: "++",
      left: "i"
    }
  });
});
(0, _vitest.test)("block", () => {
  (0, _vitest.expect)((0, _utils.createParse)(p => p.block())(`{ break; continue; unchecked { return; } { continue; } }`)).toMatchObject({
    statements: ["break", "continue", {
      unchecked: true,
      statements: [{}]
    }, {
      unchecked: false,
      statements: ["continue"]
    }]
  });
});