"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keysInNode = exports.isSyntaxNodeList = exports.isSyntaxNode = exports.formatString = exports.Position = exports.Location = exports.BaseNodeUnion = exports.BaseNodeString = exports.BaseNodeList = exports.BaseNode = void 0;
class Position {
  constructor(line, column) {
    this.line = line;
    this.column = column;
  }
  static create(line, column) {
    return new Position(line, column);
  }
}
exports.Position = Position;
class Location {
  constructor(start, end, source) {
    this.start = start;
    this.end = end;
    this.source = source;
  }
  static create(start, end, source) {
    return new Location(start, end, source);
  }
}
exports.Location = Location;
const formatString = str => {
  return str.substring(1, str.length - 1);
};
exports.formatString = formatString;
const isSyntaxNode = node => {
  return (node instanceof BaseNode || node instanceof BaseNodeString || node instanceof BaseNodeUnion) && !!node.type;
};
exports.isSyntaxNode = isSyntaxNode;
const isSyntaxNodeList = node => {
  return node instanceof BaseNodeList || Array.isArray(node) && node.every(isSyntaxNode);
};
exports.isSyntaxNodeList = isSyntaxNodeList;
const keysInNode = node => {
  const forbiddenKeys = ["context", "serialize", "print"];
  const keys = [];
  for (const key in node) {
    if (Object.prototype.hasOwnProperty.call(node, key) && !forbiddenKeys.includes(key)) {
      keys.push(key);
    }
  }
  return keys;
};
exports.keysInNode = keysInNode;
class BaseNode {
  type;
  range;
  location;
  constructor(ctx, _visitor) {
    const start = ctx.start?.start ?? 0;
    const end = ctx.stop?.stop ?? start;
    this.range = [start, end];
    const startPosition = Position.create(ctx.start?.line ?? 1, ctx.start?.column ?? 0);
    const endPosition = Position.create(ctx.stop?.line ?? startPosition.line, ctx.stop?.column ?? startPosition.column);
    this.location = Location.create(startPosition, endPosition, `${start}:${end - start}`);
  }
  /** @ignore */
  // context: ParserRuleContext;
  /** @ignore */
  // print?: SyntaxPrint<typeof this>;
}
exports.BaseNode = BaseNode;
class BaseNodeList extends Array {
  constructor(ctxList, visitor, formatter = ctx => ctx.accept(visitor)) {
    super(...ctxList.map(formatter));
  }
}
exports.BaseNodeList = BaseNodeList;
class BaseNodeString extends BaseNode {
  name;
  constructor(ctx, visitor) {
    super(ctx, visitor);
    this.name = ctx.getText();
  }
}
exports.BaseNodeString = BaseNodeString;
class BaseNodeUnion extends BaseNode {
  constructor(_ctx, list, visitor) {
    super(_ctx, visitor);
    const target = (list ?? []).find(Boolean);
    if (target) {
      return target.accept(visitor);
    }
  }
}
exports.BaseNodeUnion = BaseNodeUnion;