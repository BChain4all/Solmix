import * as parser from '../antlr4';
import * as ast from './index';
export declare class SolidityASTBuilder extends parser.SolidityParserVisitor<ast.SyntaxNode | any> {
    visitSourceUnit: (ctx: parser.SourceUnitContext) => ast.SourceUnit;
    visitPragmaDirective: (ctx: parser.PragmaDirectiveContext) => ast.PragmaDirective;
    visitImportDirective: (ctx: parser.ImportDirectiveContext) => ast.ImportDirective;
    visitImportAliases: (ctx: parser.ImportAliasesContext) => ast.ImportAliases;
    visitPath: (ctx: parser.PathContext) => ast.Path;
    visitSymbolAliases: (ctx: parser.SymbolAliasesContext) => {
        [n: number]: ast.ImportAliases;
        type: "SymbolAliases";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.ImportAliases | undefined;
        push(...items: ast.ImportAliases[]): number;
        concat(...items: ConcatArray<ast.ImportAliases>[]): ast.ImportAliases[];
        concat(...items: (ast.ImportAliases | ConcatArray<ast.ImportAliases>)[]): ast.ImportAliases[];
        join(separator?: string | undefined): string;
        reverse(): ast.ImportAliases[];
        shift(): ast.ImportAliases | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.ImportAliases[];
        sort(compareFn?: ((a: ast.ImportAliases, b: ast.ImportAliases) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.ImportAliases[];
        splice(start: number, deleteCount: number, ...items: ast.ImportAliases[]): ast.ImportAliases[];
        unshift(...items: ast.ImportAliases[]): number;
        indexOf(searchElement: ast.ImportAliases, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.ImportAliases, fromIndex?: number | undefined): number;
        every<S extends ast.ImportAliases>(predicate: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.ImportAliases>(predicate: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.ImportAliases, index: number, array: ast.ImportAliases[]) => unknown, thisArg?: any): ast.ImportAliases[];
        reduce(callbackfn: (previousValue: ast.ImportAliases, currentValue: ast.ImportAliases, currentIndex: number, array: ast.ImportAliases[]) => ast.ImportAliases): ast.ImportAliases;
        reduce(callbackfn: (previousValue: ast.ImportAliases, currentValue: ast.ImportAliases, currentIndex: number, array: ast.ImportAliases[]) => ast.ImportAliases, initialValue: ast.ImportAliases): ast.ImportAliases;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.ImportAliases, currentIndex: number, array: ast.ImportAliases[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.ImportAliases, currentValue: ast.ImportAliases, currentIndex: number, array: ast.ImportAliases[]) => ast.ImportAliases): ast.ImportAliases;
        reduceRight(callbackfn: (previousValue: ast.ImportAliases, currentValue: ast.ImportAliases, currentIndex: number, array: ast.ImportAliases[]) => ast.ImportAliases, initialValue: ast.ImportAliases): ast.ImportAliases;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.ImportAliases, currentIndex: number, array: ast.ImportAliases[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.ImportAliases>(predicate: (value: ast.ImportAliases, index: number, obj: ast.ImportAliases[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.ImportAliases, index: number, obj: ast.ImportAliases[]) => unknown, thisArg?: any): ast.ImportAliases | undefined;
        findIndex(predicate: (value: ast.ImportAliases, index: number, obj: ast.ImportAliases[]) => unknown, thisArg?: any): number;
        fill(value: ast.ImportAliases, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.ImportAliases]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.ImportAliases>;
        includes(searchElement: ast.ImportAliases, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.ImportAliases>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitContractDefinition: (ctx: parser.ContractDefinitionContext) => ast.ContractDefinition;
    visitInterfaceDefinition: (ctx: parser.InterfaceDefinitionContext) => ast.ContractDefinition;
    visitLibraryDefinition: (ctx: parser.LibraryDefinitionContext) => ast.ContractDefinition;
    visitInheritanceSpecifierList: (ctx: parser.InheritanceSpecifierListContext) => {
        [n: number]: ast.InheritanceSpecifier;
        type: "InheritanceSpecifierList";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.InheritanceSpecifier | undefined;
        push(...items: ast.InheritanceSpecifier[]): number;
        concat(...items: ConcatArray<ast.InheritanceSpecifier>[]): ast.InheritanceSpecifier[];
        concat(...items: (ast.InheritanceSpecifier | ConcatArray<ast.InheritanceSpecifier>)[]): ast.InheritanceSpecifier[];
        join(separator?: string | undefined): string;
        reverse(): ast.InheritanceSpecifier[];
        shift(): ast.InheritanceSpecifier | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.InheritanceSpecifier[];
        sort(compareFn?: ((a: ast.InheritanceSpecifier, b: ast.InheritanceSpecifier) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.InheritanceSpecifier[];
        splice(start: number, deleteCount: number, ...items: ast.InheritanceSpecifier[]): ast.InheritanceSpecifier[];
        unshift(...items: ast.InheritanceSpecifier[]): number;
        indexOf(searchElement: ast.InheritanceSpecifier, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.InheritanceSpecifier, fromIndex?: number | undefined): number;
        every<S extends ast.InheritanceSpecifier>(predicate: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.InheritanceSpecifier>(predicate: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.InheritanceSpecifier, index: number, array: ast.InheritanceSpecifier[]) => unknown, thisArg?: any): ast.InheritanceSpecifier[];
        reduce(callbackfn: (previousValue: ast.InheritanceSpecifier, currentValue: ast.InheritanceSpecifier, currentIndex: number, array: ast.InheritanceSpecifier[]) => ast.InheritanceSpecifier): ast.InheritanceSpecifier;
        reduce(callbackfn: (previousValue: ast.InheritanceSpecifier, currentValue: ast.InheritanceSpecifier, currentIndex: number, array: ast.InheritanceSpecifier[]) => ast.InheritanceSpecifier, initialValue: ast.InheritanceSpecifier): ast.InheritanceSpecifier;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.InheritanceSpecifier, currentIndex: number, array: ast.InheritanceSpecifier[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.InheritanceSpecifier, currentValue: ast.InheritanceSpecifier, currentIndex: number, array: ast.InheritanceSpecifier[]) => ast.InheritanceSpecifier): ast.InheritanceSpecifier;
        reduceRight(callbackfn: (previousValue: ast.InheritanceSpecifier, currentValue: ast.InheritanceSpecifier, currentIndex: number, array: ast.InheritanceSpecifier[]) => ast.InheritanceSpecifier, initialValue: ast.InheritanceSpecifier): ast.InheritanceSpecifier;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.InheritanceSpecifier, currentIndex: number, array: ast.InheritanceSpecifier[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.InheritanceSpecifier>(predicate: (value: ast.InheritanceSpecifier, index: number, obj: ast.InheritanceSpecifier[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.InheritanceSpecifier, index: number, obj: ast.InheritanceSpecifier[]) => unknown, thisArg?: any): ast.InheritanceSpecifier | undefined;
        findIndex(predicate: (value: ast.InheritanceSpecifier, index: number, obj: ast.InheritanceSpecifier[]) => unknown, thisArg?: any): number;
        fill(value: ast.InheritanceSpecifier, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.InheritanceSpecifier]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.InheritanceSpecifier>;
        includes(searchElement: ast.InheritanceSpecifier, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.InheritanceSpecifier>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitInheritanceSpecifier: (ctx: parser.InheritanceSpecifierContext) => ast.InheritanceSpecifier;
    visitContractBodyElement: (ctx: parser.ContractBodyElementContext) => ast.ContractBodyElement;
    visitNamedArgument: (ctx: parser.NamedArgumentContext) => ast.NamedArgument;
    visitCallArgumentList: (ctx: parser.CallArgumentListContext) => {
        [n: number]: ast.ExpressionNode;
        type: "CallArgumentList";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.ExpressionNode | undefined;
        push(...items: ast.ExpressionNode[]): number;
        concat(...items: ConcatArray<ast.ExpressionNode>[]): ast.ExpressionNode[];
        concat(...items: (ast.ExpressionNode | ConcatArray<ast.ExpressionNode>)[]): ast.ExpressionNode[];
        join(separator?: string | undefined): string;
        reverse(): ast.ExpressionNode[];
        shift(): ast.ExpressionNode | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.ExpressionNode[];
        sort(compareFn?: ((a: ast.ExpressionNode, b: ast.ExpressionNode) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.ExpressionNode[];
        splice(start: number, deleteCount: number, ...items: ast.ExpressionNode[]): ast.ExpressionNode[];
        unshift(...items: ast.ExpressionNode[]): number;
        indexOf(searchElement: ast.ExpressionNode, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.ExpressionNode, fromIndex?: number | undefined): number;
        every<S extends ast.ExpressionNode>(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.ExpressionNode>(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => unknown, thisArg?: any): ast.ExpressionNode[];
        reduce(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode): ast.ExpressionNode;
        reduce(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode, initialValue: ast.ExpressionNode): ast.ExpressionNode;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode): ast.ExpressionNode;
        reduceRight(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode, initialValue: ast.ExpressionNode): ast.ExpressionNode;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.ExpressionNode>(predicate: (value: ast.ExpressionNode, index: number, obj: ast.ExpressionNode[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.ExpressionNode, index: number, obj: ast.ExpressionNode[]) => unknown, thisArg?: any): ast.ExpressionNode | undefined;
        findIndex(predicate: (value: ast.ExpressionNode, index: number, obj: ast.ExpressionNode[]) => unknown, thisArg?: any): number;
        fill(value: ast.ExpressionNode, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.ExpressionNode]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.ExpressionNode>;
        includes(searchElement: ast.ExpressionNode, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.ExpressionNode>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitIdentifierPath: (ctx: parser.IdentifierPathContext) => ast.IdentifierPath;
    visitModifierInvocation: (ctx: parser.ModifierInvocationContext) => ast.ModifierInvocation;
    visitVisibility: (ctx: parser.VisibilityContext) => ast.Visibility;
    visitParameterList: (ctx: parser.ParameterListContext) => {
        [n: number]: ast.VariableDeclaration;
        type: "ParameterList";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.VariableDeclaration | undefined;
        push(...items: ast.VariableDeclaration[]): number;
        concat(...items: ConcatArray<ast.VariableDeclaration>[]): ast.VariableDeclaration[];
        concat(...items: (ast.VariableDeclaration | ConcatArray<ast.VariableDeclaration>)[]): ast.VariableDeclaration[];
        join(separator?: string | undefined): string;
        reverse(): ast.VariableDeclaration[];
        shift(): ast.VariableDeclaration | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.VariableDeclaration[];
        sort(compareFn?: ((a: ast.VariableDeclaration, b: ast.VariableDeclaration) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.VariableDeclaration[];
        splice(start: number, deleteCount: number, ...items: ast.VariableDeclaration[]): ast.VariableDeclaration[];
        unshift(...items: ast.VariableDeclaration[]): number;
        indexOf(searchElement: ast.VariableDeclaration, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.VariableDeclaration, fromIndex?: number | undefined): number;
        every<S extends ast.VariableDeclaration>(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.VariableDeclaration>(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => unknown, thisArg?: any): ast.VariableDeclaration[];
        reduce(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration): ast.VariableDeclaration;
        reduce(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration, initialValue: ast.VariableDeclaration): ast.VariableDeclaration;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration): ast.VariableDeclaration;
        reduceRight(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration, initialValue: ast.VariableDeclaration): ast.VariableDeclaration;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.VariableDeclaration>(predicate: (value: ast.VariableDeclaration, index: number, obj: ast.VariableDeclaration[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.VariableDeclaration, index: number, obj: ast.VariableDeclaration[]) => unknown, thisArg?: any): ast.VariableDeclaration | undefined;
        findIndex(predicate: (value: ast.VariableDeclaration, index: number, obj: ast.VariableDeclaration[]) => unknown, thisArg?: any): number;
        fill(value: ast.VariableDeclaration, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.VariableDeclaration]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.VariableDeclaration>;
        includes(searchElement: ast.VariableDeclaration, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.VariableDeclaration>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitParameterDeclaration: (ctx: parser.ParameterDeclarationContext) => ast.VariableDeclaration;
    visitConstructorDefinition: (ctx: parser.ConstructorDefinitionContext) => ast.FunctionDefinition;
    visitStateMutability: (ctx: parser.StateMutabilityContext) => ast.StateMutability;
    visitOverrideSpecifier: (ctx: parser.OverrideSpecifierContext) => {
        [n: number]: ast.IdentifierPath;
        type: "OverrideSpecifier";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.IdentifierPath | undefined;
        push(...items: ast.IdentifierPath[]): number;
        concat(...items: ConcatArray<ast.IdentifierPath>[]): ast.IdentifierPath[];
        concat(...items: (ast.IdentifierPath | ConcatArray<ast.IdentifierPath>)[]): ast.IdentifierPath[];
        join(separator?: string | undefined): string;
        reverse(): ast.IdentifierPath[];
        shift(): ast.IdentifierPath | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.IdentifierPath[];
        sort(compareFn?: ((a: ast.IdentifierPath, b: ast.IdentifierPath) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.IdentifierPath[];
        splice(start: number, deleteCount: number, ...items: ast.IdentifierPath[]): ast.IdentifierPath[];
        unshift(...items: ast.IdentifierPath[]): number;
        indexOf(searchElement: ast.IdentifierPath, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.IdentifierPath, fromIndex?: number | undefined): number;
        every<S extends ast.IdentifierPath>(predicate: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.IdentifierPath>(predicate: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.IdentifierPath, index: number, array: ast.IdentifierPath[]) => unknown, thisArg?: any): ast.IdentifierPath[];
        reduce(callbackfn: (previousValue: ast.IdentifierPath, currentValue: ast.IdentifierPath, currentIndex: number, array: ast.IdentifierPath[]) => ast.IdentifierPath): ast.IdentifierPath;
        reduce(callbackfn: (previousValue: ast.IdentifierPath, currentValue: ast.IdentifierPath, currentIndex: number, array: ast.IdentifierPath[]) => ast.IdentifierPath, initialValue: ast.IdentifierPath): ast.IdentifierPath;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.IdentifierPath, currentIndex: number, array: ast.IdentifierPath[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.IdentifierPath, currentValue: ast.IdentifierPath, currentIndex: number, array: ast.IdentifierPath[]) => ast.IdentifierPath): ast.IdentifierPath;
        reduceRight(callbackfn: (previousValue: ast.IdentifierPath, currentValue: ast.IdentifierPath, currentIndex: number, array: ast.IdentifierPath[]) => ast.IdentifierPath, initialValue: ast.IdentifierPath): ast.IdentifierPath;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.IdentifierPath, currentIndex: number, array: ast.IdentifierPath[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.IdentifierPath>(predicate: (value: ast.IdentifierPath, index: number, obj: ast.IdentifierPath[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.IdentifierPath, index: number, obj: ast.IdentifierPath[]) => unknown, thisArg?: any): ast.IdentifierPath | undefined;
        findIndex(predicate: (value: ast.IdentifierPath, index: number, obj: ast.IdentifierPath[]) => unknown, thisArg?: any): number;
        fill(value: ast.IdentifierPath, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.IdentifierPath]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.IdentifierPath>;
        includes(searchElement: ast.IdentifierPath, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.IdentifierPath>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitFunctionDefinition: (ctx: parser.FunctionDefinitionContext) => ast.FunctionDefinition;
    visitModifierDefinition: (ctx: parser.ModifierDefinitionContext) => ast.ModifierDefinition;
    visitFallbackFunctionDefinition: (ctx: parser.FallbackFunctionDefinitionContext) => ast.FunctionDefinition;
    visitReceiveFunctionDefinition: (ctx: parser.ReceiveFunctionDefinitionContext) => ast.FunctionDefinition;
    visitStructDefinition: (ctx: parser.StructDefinitionContext) => ast.StructDefinition;
    visitStructMember: (ctx: parser.StructMemberContext) => ast.StructMember;
    visitEnumDefinition: (ctx: parser.EnumDefinitionContext) => ast.EnumDefinition;
    visitUserDefinedValueTypeDefinition: (ctx: parser.UserDefinedValueTypeDefinitionContext) => ast.UserDefinedValueTypeDefinition;
    visitStateVariableDeclaration: (ctx: parser.StateVariableDeclarationContext) => ast.VariableDeclaration;
    visitConstantVariableDeclaration: (ctx: parser.ConstantVariableDeclarationContext) => ast.VariableDeclaration;
    visitEventParameter: (ctx: parser.EventParameterContext) => ast.VariableDeclaration;
    visitEventDefinition: (ctx: parser.EventDefinitionContext) => ast.EventDefinition;
    visitErrorParameter: (ctx: parser.ErrorParameterContext) => ast.VariableDeclaration;
    visitErrorDefinition: (ctx: parser.ErrorDefinitionContext) => ast.ErrorDefinition;
    visitUserDefinableOperator: (ctx: parser.UserDefinableOperatorContext) => ast.UserDefinableOperator;
    visitUsingAliases: (ctx: parser.UsingAliasesContext) => ast.UsingAliases;
    visitUsingDirective: (ctx: parser.UsingDirectiveContext) => ast.UsingDirective;
    visitTypeName: (ctx: parser.TypeNameContext) => {
        type: "TypeName";
        baseType: ast.IdentifierPath | ast.ElementaryTypeName | ast.FunctionTypeName | ast.MappingType;
        expression: ast.ExpressionNode | null;
        name: any;
        range: [number, number];
        location: import("./base").Location;
    };
    visitElementaryTypeName: (ctx: parser.ElementaryTypeNameContext) => ast.ElementaryTypeName;
    visitFunctionTypeName: (ctx: parser.FunctionTypeNameContext) => ast.FunctionTypeName;
    visitVariableDeclaration: (ctx: parser.VariableDeclarationContext) => ast.VariableDeclaration;
    visitDataLocation: (ctx: parser.DataLocationContext) => ast.DataLocation;
    visitExpression: (ctx: parser.ExpressionContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitAssignOp: (ctx: parser.AssignOpContext) => ast.AssignOp;
    visitTupleExpression: (ctx: parser.TupleExpressionContext) => ast.TupleExpression;
    visitInlineArrayExpression: (ctx: parser.InlineArrayExpressionContext) => {
        [n: number]: ast.ExpressionNode;
        type: "InlineArrayExpression";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.ExpressionNode | undefined;
        push(...items: ast.ExpressionNode[]): number;
        concat(...items: ConcatArray<ast.ExpressionNode>[]): ast.ExpressionNode[];
        concat(...items: (ast.ExpressionNode | ConcatArray<ast.ExpressionNode>)[]): ast.ExpressionNode[];
        join(separator?: string | undefined): string;
        reverse(): ast.ExpressionNode[];
        shift(): ast.ExpressionNode | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.ExpressionNode[];
        sort(compareFn?: ((a: ast.ExpressionNode, b: ast.ExpressionNode) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.ExpressionNode[];
        splice(start: number, deleteCount: number, ...items: ast.ExpressionNode[]): ast.ExpressionNode[];
        unshift(...items: ast.ExpressionNode[]): number;
        indexOf(searchElement: ast.ExpressionNode, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.ExpressionNode, fromIndex?: number | undefined): number;
        every<S extends ast.ExpressionNode>(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.ExpressionNode>(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.ExpressionNode, index: number, array: ast.ExpressionNode[]) => unknown, thisArg?: any): ast.ExpressionNode[];
        reduce(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode): ast.ExpressionNode;
        reduce(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode, initialValue: ast.ExpressionNode): ast.ExpressionNode;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode): ast.ExpressionNode;
        reduceRight(callbackfn: (previousValue: ast.ExpressionNode, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => ast.ExpressionNode, initialValue: ast.ExpressionNode): ast.ExpressionNode;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.ExpressionNode, currentIndex: number, array: ast.ExpressionNode[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.ExpressionNode>(predicate: (value: ast.ExpressionNode, index: number, obj: ast.ExpressionNode[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.ExpressionNode, index: number, obj: ast.ExpressionNode[]) => unknown, thisArg?: any): ast.ExpressionNode | undefined;
        findIndex(predicate: (value: ast.ExpressionNode, index: number, obj: ast.ExpressionNode[]) => unknown, thisArg?: any): number;
        fill(value: ast.ExpressionNode, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.ExpressionNode]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.ExpressionNode>;
        includes(searchElement: ast.ExpressionNode, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.ExpressionNode>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitIdentifier: (ctx: parser.IdentifierContext) => ast.Identifier;
    visitLiteral: (ctx: parser.LiteralContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitLiteralWithSubDenomination: (ctx: parser.LiteralWithSubDenominationContext) => ast.NumberLiteral;
    visitBooleanLiteral: (ctx: parser.BooleanLiteralContext) => ast.BooleanLiteral;
    visitStringLiteral: (ctx: parser.StringLiteralContext) => ast.StringLiteral;
    visitHexStringLiteral: (ctx: parser.HexStringLiteralContext) => ast.HexStringLiteral;
    visitUnicodeStringLiteral: (ctx: parser.UnicodeStringLiteralContext) => ast.UnicodeStringLiteral;
    visitNumberLiteral: (ctx: parser.NumberLiteralContext) => ast.NumberLiteral;
    visitBlock: (ctx: parser.BlockContext) => ast.Block;
    visitUncheckedBlock: (ctx: parser.UncheckedBlockContext) => ast.Block;
    visitStatement: (ctx: parser.StatementContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitSimpleStatement: (ctx: parser.SimpleStatementContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitIfStatement: (ctx: parser.IfStatementContext) => ast.IfStatement;
    visitForStatement: (ctx: parser.ForStatementContext) => ast.ForStatement;
    visitWhileStatement: (ctx: parser.WhileStatementContext) => ast.WhileStatement;
    visitDoWhileStatement: (ctx: parser.DoWhileStatementContext) => ast.DoWhileStatement;
    visitContinueStatement: (ctx: parser.ContinueStatementContext) => ast.ContinueStatement;
    visitBreakStatement: (ctx: parser.BreakStatementContext) => ast.BreakStatement;
    visitTryStatement: (ctx: parser.TryStatementContext) => ast.TryStatement;
    visitCatchClause: (ctx: parser.CatchClauseContext) => ast.CatchClause;
    visitReturnStatement: (ctx: parser.ReturnStatementContext) => ast.ReturnStatement;
    visitEmitStatement: (ctx: parser.EmitStatementContext) => ast.EmitStatement;
    visitRevertStatement: (ctx: parser.RevertStatementContext) => ast.RevertStatement;
    visitAssemblyStatement: (ctx: parser.AssemblyStatementContext) => ast.AssemblyStatement;
    visitAssemblyFlags: (ctx: parser.AssemblyFlagsContext) => {
        [n: number]: any;
        type: "AssemblyFlags";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): any;
        push(...items: any[]): number;
        concat(...items: ConcatArray<any>[]): any[];
        concat(...items: any[]): any[];
        join(separator?: string | undefined): string;
        reverse(): any[];
        shift(): any;
        slice(start?: number | undefined, end?: number | undefined): any[];
        sort(compareFn?: ((a: any, b: any) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): any[];
        splice(start: number, deleteCount: number, ...items: any[]): any[];
        unshift(...items: any[]): number;
        indexOf(searchElement: any, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: any, fromIndex?: number | undefined): number;
        every<S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any): U[];
        filter<S_1 extends any>(predicate: (value: any, index: number, array: any[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): any[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: any, currentIndex: number, array: any[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: any, currentIndex: number, array: any[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends any>(predicate: (value: any, index: number, obj: any[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): any;
        findIndex(predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): number;
        fill(value: any, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, any]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<any>;
        includes(searchElement: any, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<any>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitVariableDeclarationList: (ctx: parser.VariableDeclarationListContext) => {
        [n: number]: ast.VariableDeclaration;
        type: "VariableDeclarationList";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.VariableDeclaration | undefined;
        push(...items: ast.VariableDeclaration[]): number;
        concat(...items: ConcatArray<ast.VariableDeclaration>[]): ast.VariableDeclaration[];
        concat(...items: (ast.VariableDeclaration | ConcatArray<ast.VariableDeclaration>)[]): ast.VariableDeclaration[];
        join(separator?: string | undefined): string;
        reverse(): ast.VariableDeclaration[];
        shift(): ast.VariableDeclaration | undefined;
        slice(start?: number | undefined, end?: number | undefined): ast.VariableDeclaration[];
        sort(compareFn?: ((a: ast.VariableDeclaration, b: ast.VariableDeclaration) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): ast.VariableDeclaration[];
        splice(start: number, deleteCount: number, ...items: ast.VariableDeclaration[]): ast.VariableDeclaration[];
        unshift(...items: ast.VariableDeclaration[]): number;
        indexOf(searchElement: ast.VariableDeclaration, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.VariableDeclaration, fromIndex?: number | undefined): number;
        every<S extends ast.VariableDeclaration>(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.VariableDeclaration>(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.VariableDeclaration, index: number, array: ast.VariableDeclaration[]) => unknown, thisArg?: any): ast.VariableDeclaration[];
        reduce(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration): ast.VariableDeclaration;
        reduce(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration, initialValue: ast.VariableDeclaration): ast.VariableDeclaration;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration): ast.VariableDeclaration;
        reduceRight(callbackfn: (previousValue: ast.VariableDeclaration, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => ast.VariableDeclaration, initialValue: ast.VariableDeclaration): ast.VariableDeclaration;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.VariableDeclaration, currentIndex: number, array: ast.VariableDeclaration[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.VariableDeclaration>(predicate: (value: ast.VariableDeclaration, index: number, obj: ast.VariableDeclaration[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.VariableDeclaration, index: number, obj: ast.VariableDeclaration[]) => unknown, thisArg?: any): ast.VariableDeclaration | undefined;
        findIndex(predicate: (value: ast.VariableDeclaration, index: number, obj: ast.VariableDeclaration[]) => unknown, thisArg?: any): number;
        fill(value: ast.VariableDeclaration, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.VariableDeclaration]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.VariableDeclaration>;
        includes(searchElement: ast.VariableDeclaration, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.VariableDeclaration>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitVariableDeclarationTuple: (ctx: parser.VariableDeclarationTupleContext) => {
        [n: number]: ast.VariableDeclaration | null;
        type: "VariableDeclarationTuple";
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): ast.VariableDeclaration | null | undefined;
        push(...items: (ast.VariableDeclaration | null)[]): number;
        concat(...items: ConcatArray<ast.VariableDeclaration | null>[]): (ast.VariableDeclaration | null)[];
        concat(...items: (ast.VariableDeclaration | ConcatArray<ast.VariableDeclaration | null> | null)[]): (ast.VariableDeclaration | null)[];
        join(separator?: string | undefined): string;
        reverse(): (ast.VariableDeclaration | null)[];
        shift(): ast.VariableDeclaration | null | undefined;
        slice(start?: number | undefined, end?: number | undefined): (ast.VariableDeclaration | null)[];
        sort(compareFn?: ((a: ast.VariableDeclaration | null, b: ast.VariableDeclaration | null) => number) | undefined): any;
        splice(start: number, deleteCount?: number | undefined): (ast.VariableDeclaration | null)[];
        splice(start: number, deleteCount: number, ...items: (ast.VariableDeclaration | null)[]): (ast.VariableDeclaration | null)[];
        unshift(...items: (ast.VariableDeclaration | null)[]): number;
        indexOf(searchElement: ast.VariableDeclaration | null, fromIndex?: number | undefined): number;
        lastIndexOf(searchElement: ast.VariableDeclaration | null, fromIndex?: number | undefined): number;
        every<S extends ast.VariableDeclaration | null>(predicate: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => U, thisArg?: any): U[];
        filter<S_1 extends ast.VariableDeclaration | null>(predicate: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: ast.VariableDeclaration | null, index: number, array: (ast.VariableDeclaration | null)[]) => unknown, thisArg?: any): (ast.VariableDeclaration | null)[];
        reduce(callbackfn: (previousValue: ast.VariableDeclaration | null, currentValue: ast.VariableDeclaration | null, currentIndex: number, array: (ast.VariableDeclaration | null)[]) => ast.VariableDeclaration | null): ast.VariableDeclaration | null;
        reduce(callbackfn: (previousValue: ast.VariableDeclaration | null, currentValue: ast.VariableDeclaration | null, currentIndex: number, array: (ast.VariableDeclaration | null)[]) => ast.VariableDeclaration | null, initialValue: ast.VariableDeclaration | null): ast.VariableDeclaration | null;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: ast.VariableDeclaration | null, currentIndex: number, array: (ast.VariableDeclaration | null)[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: ast.VariableDeclaration | null, currentValue: ast.VariableDeclaration | null, currentIndex: number, array: (ast.VariableDeclaration | null)[]) => ast.VariableDeclaration | null): ast.VariableDeclaration | null;
        reduceRight(callbackfn: (previousValue: ast.VariableDeclaration | null, currentValue: ast.VariableDeclaration | null, currentIndex: number, array: (ast.VariableDeclaration | null)[]) => ast.VariableDeclaration | null, initialValue: ast.VariableDeclaration | null): ast.VariableDeclaration | null;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: ast.VariableDeclaration | null, currentIndex: number, array: (ast.VariableDeclaration | null)[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends ast.VariableDeclaration | null>(predicate: (value: ast.VariableDeclaration | null, index: number, obj: (ast.VariableDeclaration | null)[]) => value is S_2, thisArg?: any): S_2 | undefined;
        find(predicate: (value: ast.VariableDeclaration | null, index: number, obj: (ast.VariableDeclaration | null)[]) => unknown, thisArg?: any): ast.VariableDeclaration | null | undefined;
        findIndex(predicate: (value: ast.VariableDeclaration | null, index: number, obj: (ast.VariableDeclaration | null)[]) => unknown, thisArg?: any): number;
        fill(value: ast.VariableDeclaration | null, start?: number | undefined, end?: number | undefined): any;
        copyWithin(target: number, start?: number | undefined, end?: number | undefined): any;
        entries(): IterableIterator<[number, ast.VariableDeclaration | null]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<ast.VariableDeclaration | null>;
        includes(searchElement: ast.VariableDeclaration | null, fromIndex?: number | undefined): boolean;
        [Symbol.iterator](): IterableIterator<ast.VariableDeclaration | null>;
        readonly [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    };
    visitVariableDeclarationStatement: (ctx: parser.VariableDeclarationStatementContext) => ast.VariableDeclarationStatement;
    visitExpressionStatement: (ctx: parser.ExpressionStatementContext) => ast.ExpressionStatement;
    visitMappingType: (ctx: parser.MappingTypeContext) => ast.MappingType;
    visitMappingKeyType: (ctx: parser.MappingKeyTypeContext) => ast.MappingKeyType;
    visitMemberAccess: (ctx: parser.MemberAccessContext) => ast.MemberAccess;
    visitYulStatement: (ctx: parser.YulStatementContext) => ast.YulStatement;
    visitYulBlock: (ctx: parser.YulBlockContext) => ast.YulBlock;
    visitYulVariableDeclaration: (ctx: parser.YulVariableDeclarationContext) => ast.YulVariableDeclaration;
    visitYulAssignment: (ctx: parser.YulAssignmentContext) => ast.YulAssignment;
    visitYulIfStatement: (ctx: parser.YulIfStatementContext) => ast.YulIfStatement;
    visitYulForStatement: (ctx: parser.YulForStatementContext) => ast.YulForStatement;
    visitYulSwitchCase: (ctx: parser.YulSwitchCaseContext) => ast.YulSwitchCase;
    visitYulSwitchStatement: (ctx: parser.YulSwitchStatementContext) => ast.YulSwitchStatement;
    visitYulFunctionDefinition: (ctx: parser.YulFunctionDefinitionContext) => ast.YulFunctionDefinition;
    visitYulPath: (ctx: parser.YulPathContext) => ast.YulPath;
    visitYulFunctionCall: (ctx: parser.YulFunctionCallContext) => ast.YulFunctionCall;
    visitYulBoolean: (ctx: parser.YulBooleanContext) => ast.YulBoolean;
    visitYulLiteral: (ctx: parser.YulLiteralContext) => ast.YulLiteral;
    visitYulExpression: (ctx: parser.YulExpressionContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitUnaryPrefixOperation: (ctx: parser.UnaryPrefixOperationContext) => ast.UnaryOperation;
    visitPrimaryExpression: (ctx: parser.PrimaryExpressionContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitOrderComparison: (ctx: parser.OrderComparisonContext) => ast.BinaryOperation<parser.OrderComparisonContext>;
    visitConditional: (ctx: parser.ConditionalContext) => ast.Conditional;
    visitPayableConversion: (ctx: parser.PayableConversionContext) => ast.PayableConversion;
    visitAssignment: (ctx: parser.AssignmentContext) => ast.Assignment;
    visitUnarySuffixOperation: (ctx: parser.UnarySuffixOperationContext) => ast.UnaryOperation;
    visitShiftOperation: (ctx: parser.ShiftOperationContext) => ast.BinaryOperation<parser.ShiftOperationContext>;
    visitBitAndOperation: (ctx: parser.BitAndOperationContext) => ast.BinaryOperation<parser.BitAndOperationContext>;
    visitFunctionCall: (ctx: parser.FunctionCallContext) => ast.FunctionCall;
    visitIndexRangeAccess: (ctx: parser.IndexRangeAccessContext) => ast.IndexRangeAccess;
    visitIndexAccess: (ctx: parser.IndexAccessContext) => ast.IndexAccess;
    visitAddSubOperation: (ctx: parser.AddSubOperationContext) => ast.BinaryOperation<parser.AddSubOperationContext>;
    visitBitOrOperation: (ctx: parser.BitOrOperationContext) => ast.BinaryOperation<parser.BitOrOperationContext>;
    visitExpOperation: (ctx: parser.ExpOperationContext) => ast.BinaryOperation<parser.ExpOperationContext>;
    visitAndOperation: (ctx: parser.AndOperationContext) => ast.BinaryOperation<parser.AndOperationContext>;
    visitInlineArray: (ctx: parser.InlineArrayContext) => ast.InlineArray;
    visitOrOperation: (ctx: parser.OrOperationContext) => ast.BinaryOperation<parser.OrOperationContext>;
    visitMulDivModOperation: (ctx: parser.MulDivModOperationContext) => ast.BinaryOperation<parser.MulDivModOperationContext>;
    visitFunctionCallOptions: (ctx: parser.FunctionCallOptionsContext) => ast.FunctionCallOptions;
    visitNewExpr: (ctx: parser.NewExprContext) => ast.NewExpr;
    visitBitXorOperation: (ctx: parser.BitXorOperationContext) => ast.BinaryOperation<parser.BitXorOperationContext>;
    visitTuple: (ctx: parser.TupleContext) => {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("./base").Location;
    };
    visitEqualityComparison: (ctx: parser.EqualityComparisonContext) => ast.BinaryOperation<parser.EqualityComparisonContext>;
    visitMetaType: (ctx: parser.MetaTypeContext) => ast.MetaType;
}
export declare const solidityASTBuilder: SolidityASTBuilder;
