export class Position {
  constructor(line, column) {
    this.line = line;
    this.column = column;
  }
  static create(line, column) {
    return new Position(line, column);
  }
}
export class Location {
  constructor(start, end, source) {
    this.start = start;
    this.end = end;
    this.source = source;
  }
  static create(start, end, source) {
    return new Location(start, end, source);
  }
}
export const formatString = (str) => {
  return str.substring(1, str.length - 1);
};
export const isSyntaxNode = (node) => {
  return (node instanceof BaseNode || node instanceof BaseNodeString || node instanceof BaseNodeUnion) && !!node.type;
};
export const isSyntaxNodeList = (node) => {
  return node instanceof BaseNodeList || Array.isArray(node) && node.every(isSyntaxNode);
};
export const keysInNode = (node) => {
  const forbiddenKeys = ["context", "serialize", "print"];
  const keys = [];
  for (const key in node) {
    if (Object.prototype.hasOwnProperty.call(node, key) && !forbiddenKeys.includes(key)) {
      keys.push(key);
    }
  }
  return keys;
};
export class BaseNode {
  type;
  range;
  location;
  constructor(ctx, _visitor) {
    const start = ctx.start?.start ?? 0;
    const end = ctx.stop?.stop ?? start;
    this.range = [start, end];
    const startPosition = Position.create(ctx.start?.line ?? 1, ctx.start?.column ?? 0);
    const endPosition = Position.create(
      ctx.stop?.line ?? startPosition.line,
      ctx.stop?.column ?? startPosition.column
    );
    this.location = Location.create(startPosition, endPosition, `${start}:${end - start}`);
  }
  /** @ignore */
  // context: ParserRuleContext;
  /** @ignore */
  // print?: SyntaxPrint<typeof this>;
}
export class BaseNodeList extends Array {
  constructor(ctxList, visitor, formatter = (ctx) => ctx.accept(visitor)) {
    super(...ctxList.map(formatter));
  }
}
export class BaseNodeString extends BaseNode {
  name;
  constructor(ctx, visitor) {
    super(ctx, visitor);
    this.name = ctx.getText();
  }
}
export class BaseNodeUnion extends BaseNode {
  constructor(_ctx, list, visitor) {
    super(_ctx, visitor);
    const target = (list ?? []).find(Boolean);
    if (target) {
      return target.accept(visitor);
    }
  }
}
