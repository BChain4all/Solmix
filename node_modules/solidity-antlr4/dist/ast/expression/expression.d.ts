import { ExpressionContext, SolidityParserVisitor } from '../../antlr4';
import { ExpressionNode } from './index';
export type Expression = ExpressionNode;
export declare const Expression: {
    new (ctx: ExpressionContext, visitor: SolidityParserVisitor<any>): {
        type: "Conditional" | "UnicodeStringLiteral" | "Identifier" | "ContractDefinition" | "EnumDefinition" | "ErrorDefinition" | "EventDefinition" | "FunctionDefinition" | "ModifierDefinition" | "StructDefinition" | "StructMember" | "UserDefinedValueTypeDefinition" | "VariableDeclaration" | "AssignOp" | "Assignment" | "BinaryOperation" | "BooleanLiteral" | "FunctionCallOptions" | "FunctionCall" | "HexStringLiteral" | "IndexAccess" | "IndexRangeAccess" | "InlineArray" | "MemberAccess" | "MetaType" | "NamedArgument" | "NewExpr" | "NumberLiteral" | "PayableConversion" | "StringLiteral" | "TupleExpression" | "UnaryOperation" | "UserDefinableOperator" | "DataLocation" | "IdentifierPath" | "ImportAliases" | "ImportDirective" | "InheritanceSpecifier" | "ModifierInvocation" | "Path" | "PragmaDirective" | "SourceUnit" | "UsingAliases" | "UsingDirective" | "AssemblyStatement" | "Block" | "BreakStatement" | "CatchClause" | "ContinueStatement" | "DoWhileStatement" | "EmitStatement" | "ExpressionStatement" | "ForStatement" | "IfStatement" | "ReturnStatement" | "RevertStatement" | "TryStatement" | "VariableDeclarationStatement" | "WhileStatement" | "ElementaryTypeName" | "FunctionTypeName" | "MappingKeyType" | "MappingType" | "TypeName" | "YulAssignment" | "YulBlock" | "YulBoolean" | "YulForStatement" | "YulFunctionCall" | "YulFunctionDefinition" | "YulIfStatement" | "YulLiteral" | "YulPath" | "YulStatement" | "YulSwitchCase" | "YulSwitchStatement" | "YulVariableDeclaration";
        range: [number, number];
        location: import("../base").Location;
    };
};
