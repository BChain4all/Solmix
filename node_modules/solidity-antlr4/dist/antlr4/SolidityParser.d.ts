import * as antlr from "antlr4ng";
import { Token } from "antlr4ng";
import { SolidityParserListener } from "./SolidityParserListener.js";
import { SolidityParserVisitor } from "./SolidityParserVisitor.js";
export declare class SolidityParser extends antlr.Parser {
    static readonly ReservedKeywords = 1;
    static readonly Abstract = 2;
    static readonly Address = 3;
    static readonly Anonymous = 4;
    static readonly As = 5;
    static readonly Assembly = 6;
    static readonly Bool = 7;
    static readonly Break = 8;
    static readonly Bytes = 9;
    static readonly Calldata = 10;
    static readonly Catch = 11;
    static readonly Constant = 12;
    static readonly Constructor = 13;
    static readonly Continue = 14;
    static readonly Contract = 15;
    static readonly Delete = 16;
    static readonly Do = 17;
    static readonly Else = 18;
    static readonly Emit = 19;
    static readonly Enum = 20;
    static readonly Error = 21;
    static readonly Event = 22;
    static readonly External = 23;
    static readonly Fallback = 24;
    static readonly False = 25;
    static readonly Fixed = 26;
    static readonly FixedBytes = 27;
    static readonly For = 28;
    static readonly From = 29;
    static readonly Function = 30;
    static readonly Global = 31;
    static readonly Hex = 32;
    static readonly If = 33;
    static readonly Immutable = 34;
    static readonly Import = 35;
    static readonly Indexed = 36;
    static readonly Interface = 37;
    static readonly Internal = 38;
    static readonly Is = 39;
    static readonly Library = 40;
    static readonly Mapping = 41;
    static readonly Memory = 42;
    static readonly Modifier = 43;
    static readonly New = 44;
    static readonly SubDenomination = 45;
    static readonly Override = 46;
    static readonly Payable = 47;
    static readonly Pragma = 48;
    static readonly Private = 49;
    static readonly Public = 50;
    static readonly Pure = 51;
    static readonly Receive = 52;
    static readonly Return = 53;
    static readonly Returns = 54;
    static readonly Revert = 55;
    static readonly SignedIntegerType = 56;
    static readonly Storage = 57;
    static readonly String = 58;
    static readonly Struct = 59;
    static readonly True = 60;
    static readonly Try = 61;
    static readonly Type = 62;
    static readonly Ufixed = 63;
    static readonly Unchecked = 64;
    static readonly Unicode = 65;
    static readonly UnsignedIntegerType = 66;
    static readonly Using = 67;
    static readonly View = 68;
    static readonly Virtual = 69;
    static readonly While = 70;
    static readonly LParen = 71;
    static readonly RParen = 72;
    static readonly LBrack = 73;
    static readonly RBrack = 74;
    static readonly LBrace = 75;
    static readonly RBrace = 76;
    static readonly Colon = 77;
    static readonly Semicolon = 78;
    static readonly Period = 79;
    static readonly Conditional = 80;
    static readonly DoubleArrow = 81;
    static readonly RightArrow = 82;
    static readonly Assign = 83;
    static readonly AssignBitOr = 84;
    static readonly AssignBitXor = 85;
    static readonly AssignBitAnd = 86;
    static readonly AssignShl = 87;
    static readonly AssignSar = 88;
    static readonly AssignShr = 89;
    static readonly AssignAdd = 90;
    static readonly AssignSub = 91;
    static readonly AssignMul = 92;
    static readonly AssignDiv = 93;
    static readonly AssignMod = 94;
    static readonly Comma = 95;
    static readonly Or = 96;
    static readonly And = 97;
    static readonly BitOr = 98;
    static readonly BitXor = 99;
    static readonly BitAnd = 100;
    static readonly Shl = 101;
    static readonly Sar = 102;
    static readonly Shr = 103;
    static readonly Add = 104;
    static readonly Sub = 105;
    static readonly Mul = 106;
    static readonly Div = 107;
    static readonly Mod = 108;
    static readonly Exp = 109;
    static readonly Equal = 110;
    static readonly NotEqual = 111;
    static readonly LessThan = 112;
    static readonly GreaterThan = 113;
    static readonly LessThanOrEqual = 114;
    static readonly GreaterThanOrEqual = 115;
    static readonly Not = 116;
    static readonly BitNot = 117;
    static readonly Inc = 118;
    static readonly Dec = 119;
    static readonly DoubleQuote = 120;
    static readonly SingleQuote = 121;
    static readonly NonEmptyStringLiteral = 122;
    static readonly EmptyStringLiteral = 123;
    static readonly UnicodeStringLiteral = 124;
    static readonly HexString = 125;
    static readonly HexNumber = 126;
    static readonly OctalNumber = 127;
    static readonly DecimalNumber = 128;
    static readonly DecimalNumberFollowedByIdentifier = 129;
    static readonly Identifier = 130;
    static readonly WS = 131;
    static readonly COMMENT = 132;
    static readonly LINE_COMMENT = 133;
    static readonly AssemblyDialect = 134;
    static readonly AssemblyLBrace = 135;
    static readonly AssemblyFlagString = 136;
    static readonly AssemblyBlockLParen = 137;
    static readonly AssemblyBlockRParen = 138;
    static readonly AssemblyBlockComma = 139;
    static readonly AssemblyBlockWS = 140;
    static readonly AssemblyBlockCOMMENT = 141;
    static readonly AssemblyBlockLINE_COMMENT = 142;
    static readonly YulBreak = 143;
    static readonly YulCase = 144;
    static readonly YulContinue = 145;
    static readonly YulDefault = 146;
    static readonly YulFalse = 147;
    static readonly YulFor = 148;
    static readonly YulFunction = 149;
    static readonly YulIf = 150;
    static readonly YulLeave = 151;
    static readonly YulLet = 152;
    static readonly YulSwitch = 153;
    static readonly YulTrue = 154;
    static readonly YulHex = 155;
    static readonly YulEVMBuiltin = 156;
    static readonly YulLBrace = 157;
    static readonly YulRBrace = 158;
    static readonly YulLParen = 159;
    static readonly YulRParen = 160;
    static readonly YulAssign = 161;
    static readonly YulPeriod = 162;
    static readonly YulComma = 163;
    static readonly YulArrow = 164;
    static readonly YulIdentifier = 165;
    static readonly YulHexNumber = 166;
    static readonly YulDecimalNumber = 167;
    static readonly YulStringLiteral = 168;
    static readonly YulHexStringLiteral = 169;
    static readonly YulWS = 170;
    static readonly YulCOMMENT = 171;
    static readonly YulLINE_COMMENT = 172;
    static readonly PragmaToken = 173;
    static readonly PragmaSemicolon = 174;
    static readonly PragmaWS = 175;
    static readonly PragmaCOMMENT = 176;
    static readonly PragmaLINE_COMMENT = 177;
    static readonly RULE_sourceUnit = 0;
    static readonly RULE_pragmaDirective = 1;
    static readonly RULE_importDirective = 2;
    static readonly RULE_importAliases = 3;
    static readonly RULE_path = 4;
    static readonly RULE_symbolAliases = 5;
    static readonly RULE_contractDefinition = 6;
    static readonly RULE_interfaceDefinition = 7;
    static readonly RULE_libraryDefinition = 8;
    static readonly RULE_inheritanceSpecifierList = 9;
    static readonly RULE_inheritanceSpecifier = 10;
    static readonly RULE_contractBodyElement = 11;
    static readonly RULE_namedArgument = 12;
    static readonly RULE_callArgumentList = 13;
    static readonly RULE_identifierPath = 14;
    static readonly RULE_modifierInvocation = 15;
    static readonly RULE_visibility = 16;
    static readonly RULE_parameterList = 17;
    static readonly RULE_parameterDeclaration = 18;
    static readonly RULE_constructorDefinition = 19;
    static readonly RULE_stateMutability = 20;
    static readonly RULE_overrideSpecifier = 21;
    static readonly RULE_functionDefinition = 22;
    static readonly RULE_modifierDefinition = 23;
    static readonly RULE_fallbackFunctionDefinition = 24;
    static readonly RULE_receiveFunctionDefinition = 25;
    static readonly RULE_structDefinition = 26;
    static readonly RULE_structMember = 27;
    static readonly RULE_enumDefinition = 28;
    static readonly RULE_userDefinedValueTypeDefinition = 29;
    static readonly RULE_stateVariableDeclaration = 30;
    static readonly RULE_constantVariableDeclaration = 31;
    static readonly RULE_eventParameter = 32;
    static readonly RULE_eventDefinition = 33;
    static readonly RULE_errorParameter = 34;
    static readonly RULE_errorDefinition = 35;
    static readonly RULE_userDefinableOperator = 36;
    static readonly RULE_usingDirective = 37;
    static readonly RULE_usingAliases = 38;
    static readonly RULE_typeName = 39;
    static readonly RULE_elementaryTypeName = 40;
    static readonly RULE_functionTypeName = 41;
    static readonly RULE_variableDeclaration = 42;
    static readonly RULE_dataLocation = 43;
    static readonly RULE_expression = 44;
    static readonly RULE_assignOp = 45;
    static readonly RULE_tupleExpression = 46;
    static readonly RULE_inlineArrayExpression = 47;
    static readonly RULE_identifier = 48;
    static readonly RULE_literal = 49;
    static readonly RULE_literalWithSubDenomination = 50;
    static readonly RULE_booleanLiteral = 51;
    static readonly RULE_stringLiteral = 52;
    static readonly RULE_hexStringLiteral = 53;
    static readonly RULE_unicodeStringLiteral = 54;
    static readonly RULE_numberLiteral = 55;
    static readonly RULE_block = 56;
    static readonly RULE_uncheckedBlock = 57;
    static readonly RULE_statement = 58;
    static readonly RULE_simpleStatement = 59;
    static readonly RULE_ifStatement = 60;
    static readonly RULE_forStatement = 61;
    static readonly RULE_whileStatement = 62;
    static readonly RULE_doWhileStatement = 63;
    static readonly RULE_continueStatement = 64;
    static readonly RULE_breakStatement = 65;
    static readonly RULE_tryStatement = 66;
    static readonly RULE_catchClause = 67;
    static readonly RULE_returnStatement = 68;
    static readonly RULE_emitStatement = 69;
    static readonly RULE_revertStatement = 70;
    static readonly RULE_assemblyStatement = 71;
    static readonly RULE_assemblyFlags = 72;
    static readonly RULE_variableDeclarationList = 73;
    static readonly RULE_variableDeclarationTuple = 74;
    static readonly RULE_variableDeclarationStatement = 75;
    static readonly RULE_expressionStatement = 76;
    static readonly RULE_mappingType = 77;
    static readonly RULE_mappingKeyType = 78;
    static readonly RULE_yulStatement = 79;
    static readonly RULE_yulBlock = 80;
    static readonly RULE_yulVariableDeclaration = 81;
    static readonly RULE_yulAssignment = 82;
    static readonly RULE_yulIfStatement = 83;
    static readonly RULE_yulForStatement = 84;
    static readonly RULE_yulSwitchCase = 85;
    static readonly RULE_yulSwitchStatement = 86;
    static readonly RULE_yulFunctionDefinition = 87;
    static readonly RULE_yulPath = 88;
    static readonly RULE_yulFunctionCall = 89;
    static readonly RULE_yulBoolean = 90;
    static readonly RULE_yulLiteral = 91;
    static readonly RULE_yulExpression = 92;
    static readonly literalNames: (string | null)[];
    static readonly symbolicNames: (string | null)[];
    static readonly ruleNames: string[];
    get grammarFileName(): string;
    get literalNames(): (string | null)[];
    get symbolicNames(): (string | null)[];
    get ruleNames(): string[];
    get serializedATN(): number[];
    protected createFailedPredicateException(predicate?: string, message?: string): antlr.FailedPredicateException;
    constructor(input: antlr.TokenStream);
    sourceUnit(): SourceUnitContext;
    pragmaDirective(): PragmaDirectiveContext;
    importDirective(): ImportDirectiveContext;
    importAliases(): ImportAliasesContext;
    path(): PathContext;
    symbolAliases(): SymbolAliasesContext;
    contractDefinition(): ContractDefinitionContext;
    interfaceDefinition(): InterfaceDefinitionContext;
    libraryDefinition(): LibraryDefinitionContext;
    inheritanceSpecifierList(): InheritanceSpecifierListContext;
    inheritanceSpecifier(): InheritanceSpecifierContext;
    contractBodyElement(): ContractBodyElementContext;
    namedArgument(): NamedArgumentContext;
    callArgumentList(): CallArgumentListContext;
    identifierPath(): IdentifierPathContext;
    modifierInvocation(): ModifierInvocationContext;
    visibility(): VisibilityContext;
    parameterList(): ParameterListContext;
    parameterDeclaration(): ParameterDeclarationContext;
    constructorDefinition(): ConstructorDefinitionContext;
    stateMutability(): StateMutabilityContext;
    overrideSpecifier(): OverrideSpecifierContext;
    functionDefinition(): FunctionDefinitionContext;
    modifierDefinition(): ModifierDefinitionContext;
    fallbackFunctionDefinition(): FallbackFunctionDefinitionContext;
    receiveFunctionDefinition(): ReceiveFunctionDefinitionContext;
    structDefinition(): StructDefinitionContext;
    structMember(): StructMemberContext;
    enumDefinition(): EnumDefinitionContext;
    userDefinedValueTypeDefinition(): UserDefinedValueTypeDefinitionContext;
    stateVariableDeclaration(): StateVariableDeclarationContext;
    constantVariableDeclaration(): ConstantVariableDeclarationContext;
    eventParameter(): EventParameterContext;
    eventDefinition(): EventDefinitionContext;
    errorParameter(): ErrorParameterContext;
    errorDefinition(): ErrorDefinitionContext;
    userDefinableOperator(): UserDefinableOperatorContext;
    usingDirective(): UsingDirectiveContext;
    usingAliases(): UsingAliasesContext;
    typeName(): TypeNameContext;
    typeName(_p: number): TypeNameContext;
    elementaryTypeName(allowAddressPayable: boolean): ElementaryTypeNameContext;
    functionTypeName(): FunctionTypeNameContext;
    variableDeclaration(): VariableDeclarationContext;
    dataLocation(): DataLocationContext;
    expression(): ExpressionContext;
    expression(_p: number): ExpressionContext;
    assignOp(): AssignOpContext;
    tupleExpression(): TupleExpressionContext;
    inlineArrayExpression(): InlineArrayExpressionContext;
    identifier(): IdentifierContext;
    literal(): LiteralContext;
    literalWithSubDenomination(): LiteralWithSubDenominationContext;
    booleanLiteral(): BooleanLiteralContext;
    stringLiteral(): StringLiteralContext;
    hexStringLiteral(): HexStringLiteralContext;
    unicodeStringLiteral(): UnicodeStringLiteralContext;
    numberLiteral(): NumberLiteralContext;
    block(): BlockContext;
    uncheckedBlock(): UncheckedBlockContext;
    statement(): StatementContext;
    simpleStatement(): SimpleStatementContext;
    ifStatement(): IfStatementContext;
    forStatement(): ForStatementContext;
    whileStatement(): WhileStatementContext;
    doWhileStatement(): DoWhileStatementContext;
    continueStatement(): ContinueStatementContext;
    breakStatement(): BreakStatementContext;
    tryStatement(): TryStatementContext;
    catchClause(): CatchClauseContext;
    returnStatement(): ReturnStatementContext;
    emitStatement(): EmitStatementContext;
    revertStatement(): RevertStatementContext;
    assemblyStatement(): AssemblyStatementContext;
    assemblyFlags(): AssemblyFlagsContext;
    variableDeclarationList(): VariableDeclarationListContext;
    variableDeclarationTuple(): VariableDeclarationTupleContext;
    variableDeclarationStatement(): VariableDeclarationStatementContext;
    expressionStatement(): ExpressionStatementContext;
    mappingType(): MappingTypeContext;
    mappingKeyType(): MappingKeyTypeContext;
    yulStatement(): YulStatementContext;
    yulBlock(): YulBlockContext;
    yulVariableDeclaration(): YulVariableDeclarationContext;
    yulAssignment(): YulAssignmentContext;
    yulIfStatement(): YulIfStatementContext;
    yulForStatement(): YulForStatementContext;
    yulSwitchCase(): YulSwitchCaseContext;
    yulSwitchStatement(): YulSwitchStatementContext;
    yulFunctionDefinition(): YulFunctionDefinitionContext;
    yulPath(): YulPathContext;
    yulFunctionCall(): YulFunctionCallContext;
    yulBoolean(): YulBooleanContext;
    yulLiteral(): YulLiteralContext;
    yulExpression(): YulExpressionContext;
    sempred(localContext: antlr.RuleContext | null, ruleIndex: number, predIndex: number): boolean;
    private constructorDefinition_sempred;
    private functionDefinition_sempred;
    private modifierDefinition_sempred;
    private fallbackFunctionDefinition_sempred;
    private receiveFunctionDefinition_sempred;
    private stateVariableDeclaration_sempred;
    private typeName_sempred;
    private elementaryTypeName_sempred;
    private functionTypeName_sempred;
    private expression_sempred;
    static readonly _serializedATN: number[];
    private static __ATN;
    static get _ATN(): antlr.ATN;
    private static readonly vocabulary;
    get vocabulary(): antlr.Vocabulary;
    private static readonly decisionsToDFA;
}
export declare class SourceUnitContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    EOF(): antlr.TerminalNode;
    pragmaDirective(): PragmaDirectiveContext[];
    pragmaDirective(i: number): PragmaDirectiveContext | null;
    importDirective(): ImportDirectiveContext[];
    importDirective(i: number): ImportDirectiveContext | null;
    usingDirective(): UsingDirectiveContext[];
    usingDirective(i: number): UsingDirectiveContext | null;
    contractDefinition(): ContractDefinitionContext[];
    contractDefinition(i: number): ContractDefinitionContext | null;
    interfaceDefinition(): InterfaceDefinitionContext[];
    interfaceDefinition(i: number): InterfaceDefinitionContext | null;
    libraryDefinition(): LibraryDefinitionContext[];
    libraryDefinition(i: number): LibraryDefinitionContext | null;
    functionDefinition(): FunctionDefinitionContext[];
    functionDefinition(i: number): FunctionDefinitionContext | null;
    constantVariableDeclaration(): ConstantVariableDeclarationContext[];
    constantVariableDeclaration(i: number): ConstantVariableDeclarationContext | null;
    structDefinition(): StructDefinitionContext[];
    structDefinition(i: number): StructDefinitionContext | null;
    enumDefinition(): EnumDefinitionContext[];
    enumDefinition(i: number): EnumDefinitionContext | null;
    userDefinedValueTypeDefinition(): UserDefinedValueTypeDefinitionContext[];
    userDefinedValueTypeDefinition(i: number): UserDefinedValueTypeDefinitionContext | null;
    errorDefinition(): ErrorDefinitionContext[];
    errorDefinition(i: number): ErrorDefinitionContext | null;
    eventDefinition(): EventDefinitionContext[];
    eventDefinition(i: number): EventDefinitionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class PragmaDirectiveContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Pragma(): antlr.TerminalNode;
    PragmaSemicolon(): antlr.TerminalNode;
    PragmaToken(): antlr.TerminalNode[];
    PragmaToken(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ImportDirectiveContext extends antlr.ParserRuleContext {
    _unitAlias?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Import(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    path(): PathContext | null;
    symbolAliases(): SymbolAliasesContext | null;
    From(): antlr.TerminalNode | null;
    Mul(): antlr.TerminalNode | null;
    As(): antlr.TerminalNode | null;
    identifier(): IdentifierContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ImportAliasesContext extends antlr.ParserRuleContext {
    _symbol_?: IdentifierContext;
    _alias?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    As(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class PathContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    NonEmptyStringLiteral(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class SymbolAliasesContext extends antlr.ParserRuleContext {
    _importAliases?: ImportAliasesContext;
    _aliases: ImportAliasesContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    importAliases(): ImportAliasesContext[];
    importAliases(i: number): ImportAliasesContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ContractDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Contract(): antlr.TerminalNode;
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    Abstract(): antlr.TerminalNode | null;
    inheritanceSpecifierList(): InheritanceSpecifierListContext | null;
    contractBodyElement(): ContractBodyElementContext[];
    contractBodyElement(i: number): ContractBodyElementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class InterfaceDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Interface(): antlr.TerminalNode;
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    inheritanceSpecifierList(): InheritanceSpecifierListContext | null;
    contractBodyElement(): ContractBodyElementContext[];
    contractBodyElement(i: number): ContractBodyElementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class LibraryDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Library(): antlr.TerminalNode;
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    contractBodyElement(): ContractBodyElementContext[];
    contractBodyElement(i: number): ContractBodyElementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class InheritanceSpecifierListContext extends antlr.ParserRuleContext {
    _inheritanceSpecifier?: InheritanceSpecifierContext;
    _inheritanceSpecifiers: InheritanceSpecifierContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Is(): antlr.TerminalNode;
    inheritanceSpecifier(): InheritanceSpecifierContext[];
    inheritanceSpecifier(i: number): InheritanceSpecifierContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class InheritanceSpecifierContext extends antlr.ParserRuleContext {
    _name?: IdentifierPathContext;
    _arguments?: CallArgumentListContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifierPath(): IdentifierPathContext;
    callArgumentList(): CallArgumentListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ContractBodyElementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    constructorDefinition(): ConstructorDefinitionContext | null;
    functionDefinition(): FunctionDefinitionContext | null;
    modifierDefinition(): ModifierDefinitionContext | null;
    fallbackFunctionDefinition(): FallbackFunctionDefinitionContext | null;
    receiveFunctionDefinition(): ReceiveFunctionDefinitionContext | null;
    structDefinition(): StructDefinitionContext | null;
    enumDefinition(): EnumDefinitionContext | null;
    userDefinedValueTypeDefinition(): UserDefinedValueTypeDefinitionContext | null;
    stateVariableDeclaration(): StateVariableDeclarationContext | null;
    eventDefinition(): EventDefinitionContext | null;
    errorDefinition(): ErrorDefinitionContext | null;
    usingDirective(): UsingDirectiveContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class NamedArgumentContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    _value?: ExpressionContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Colon(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class CallArgumentListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    LBrace(): antlr.TerminalNode | null;
    RBrace(): antlr.TerminalNode | null;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    namedArgument(): NamedArgumentContext[];
    namedArgument(i: number): NamedArgumentContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class IdentifierPathContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    Period(): antlr.TerminalNode[];
    Period(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ModifierInvocationContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifierPath(): IdentifierPathContext;
    callArgumentList(): CallArgumentListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class VisibilityContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Internal(): antlr.TerminalNode | null;
    External(): antlr.TerminalNode | null;
    Private(): antlr.TerminalNode | null;
    Public(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ParameterListContext extends antlr.ParserRuleContext {
    _parameterDeclaration?: ParameterDeclarationContext;
    _parameters: ParameterDeclarationContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    parameterDeclaration(): ParameterDeclarationContext[];
    parameterDeclaration(i: number): ParameterDeclarationContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ParameterDeclarationContext extends antlr.ParserRuleContext {
    _type_?: TypeNameContext;
    _location?: DataLocationContext;
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    typeName(): TypeNameContext;
    dataLocation(): DataLocationContext | null;
    identifier(): IdentifierContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ConstructorDefinitionContext extends antlr.ParserRuleContext {
    payableSet: boolean;
    visibilitySet: boolean;
    _arguments?: ParameterListContext;
    _body?: BlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Constructor(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    block(): BlockContext;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext | null;
    Payable(): antlr.TerminalNode[];
    Payable(i: number): antlr.TerminalNode | null;
    Internal(): antlr.TerminalNode[];
    Internal(i: number): antlr.TerminalNode | null;
    Public(): antlr.TerminalNode[];
    Public(i: number): antlr.TerminalNode | null;
    parameterList(): ParameterListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class StateMutabilityContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Pure(): antlr.TerminalNode | null;
    View(): antlr.TerminalNode | null;
    Payable(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class OverrideSpecifierContext extends antlr.ParserRuleContext {
    _identifierPath?: IdentifierPathContext;
    _overrides: IdentifierPathContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Override(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode | null;
    identifierPath(): IdentifierPathContext[];
    identifierPath(i: number): IdentifierPathContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class FunctionDefinitionContext extends antlr.ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    _arguments?: ParameterListContext;
    _returnParameters?: ParameterListContext;
    _body?: BlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Function(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode[];
    LParen(i: number): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode[];
    RParen(i: number): antlr.TerminalNode | null;
    identifier(): IdentifierContext | null;
    Fallback(): antlr.TerminalNode | null;
    Receive(): antlr.TerminalNode | null;
    Semicolon(): antlr.TerminalNode | null;
    visibility(): VisibilityContext[];
    visibility(i: number): VisibilityContext | null;
    stateMutability(): StateMutabilityContext[];
    stateMutability(i: number): StateMutabilityContext | null;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext | null;
    Virtual(): antlr.TerminalNode[];
    Virtual(i: number): antlr.TerminalNode | null;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext | null;
    Returns(): antlr.TerminalNode | null;
    block(): BlockContext | null;
    parameterList(): ParameterListContext[];
    parameterList(i: number): ParameterListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ModifierDefinitionContext extends antlr.ParserRuleContext {
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    _name?: IdentifierContext;
    _arguments?: ParameterListContext;
    _body?: BlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Modifier(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    Semicolon(): antlr.TerminalNode | null;
    LParen(): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode | null;
    Virtual(): antlr.TerminalNode[];
    Virtual(i: number): antlr.TerminalNode | null;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext | null;
    block(): BlockContext | null;
    parameterList(): ParameterListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class FallbackFunctionDefinitionContext extends antlr.ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    hasParameters: boolean;
    _kind?: Token | null;
    _returnParameters?: ParameterListContext;
    _body?: BlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LParen(): antlr.TerminalNode[];
    LParen(i: number): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode[];
    RParen(i: number): antlr.TerminalNode | null;
    Fallback(): antlr.TerminalNode;
    Returns(): antlr.TerminalNode | null;
    Semicolon(): antlr.TerminalNode | null;
    parameterList(): ParameterListContext[];
    parameterList(i: number): ParameterListContext | null;
    External(): antlr.TerminalNode[];
    External(i: number): antlr.TerminalNode | null;
    stateMutability(): StateMutabilityContext[];
    stateMutability(i: number): StateMutabilityContext | null;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext | null;
    Virtual(): antlr.TerminalNode[];
    Virtual(i: number): antlr.TerminalNode | null;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext | null;
    block(): BlockContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ReceiveFunctionDefinitionContext extends antlr.ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    _kind?: Token | null;
    _body?: BlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    Receive(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode | null;
    External(): antlr.TerminalNode[];
    External(i: number): antlr.TerminalNode | null;
    Payable(): antlr.TerminalNode[];
    Payable(i: number): antlr.TerminalNode | null;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext | null;
    Virtual(): antlr.TerminalNode[];
    Virtual(i: number): antlr.TerminalNode | null;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext | null;
    block(): BlockContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class StructDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    _members?: StructMemberContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Struct(): antlr.TerminalNode;
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    structMember(): StructMemberContext[];
    structMember(i: number): StructMemberContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class StructMemberContext extends antlr.ParserRuleContext {
    _type_?: TypeNameContext;
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Semicolon(): antlr.TerminalNode;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class EnumDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    _identifier?: IdentifierContext;
    _enumValues: IdentifierContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Enum(): antlr.TerminalNode;
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UserDefinedValueTypeDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Type(): antlr.TerminalNode;
    Is(): antlr.TerminalNode;
    elementaryTypeName(): ElementaryTypeNameContext;
    Semicolon(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class StateVariableDeclarationContext extends antlr.ParserRuleContext {
    constantnessSet: boolean;
    visibilitySet: boolean;
    overrideSpecifierSet: boolean;
    _type_?: TypeNameContext;
    _name?: IdentifierContext;
    _initialValue?: ExpressionContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Semicolon(): antlr.TerminalNode;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    Public(): antlr.TerminalNode[];
    Public(i: number): antlr.TerminalNode | null;
    Private(): antlr.TerminalNode[];
    Private(i: number): antlr.TerminalNode | null;
    Internal(): antlr.TerminalNode[];
    Internal(i: number): antlr.TerminalNode | null;
    Constant(): antlr.TerminalNode[];
    Constant(i: number): antlr.TerminalNode | null;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext | null;
    Immutable(): antlr.TerminalNode[];
    Immutable(i: number): antlr.TerminalNode | null;
    Assign(): antlr.TerminalNode | null;
    expression(): ExpressionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ConstantVariableDeclarationContext extends antlr.ParserRuleContext {
    _type_?: TypeNameContext;
    _name?: IdentifierContext;
    _initialValue?: ExpressionContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Constant(): antlr.TerminalNode;
    Assign(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class EventParameterContext extends antlr.ParserRuleContext {
    _type_?: TypeNameContext;
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    typeName(): TypeNameContext;
    Indexed(): antlr.TerminalNode | null;
    identifier(): IdentifierContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class EventDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    _eventParameter?: EventParameterContext;
    _parameters: EventParameterContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Event(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    Anonymous(): antlr.TerminalNode | null;
    eventParameter(): EventParameterContext[];
    eventParameter(i: number): EventParameterContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ErrorParameterContext extends antlr.ParserRuleContext {
    _type_?: TypeNameContext;
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    typeName(): TypeNameContext;
    identifier(): IdentifierContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ErrorDefinitionContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    _errorParameter?: ErrorParameterContext;
    _parameters: ErrorParameterContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Error(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    errorParameter(): ErrorParameterContext[];
    errorParameter(i: number): ErrorParameterContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UserDefinableOperatorContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    BitAnd(): antlr.TerminalNode | null;
    BitNot(): antlr.TerminalNode | null;
    BitOr(): antlr.TerminalNode | null;
    BitXor(): antlr.TerminalNode | null;
    Add(): antlr.TerminalNode | null;
    Div(): antlr.TerminalNode | null;
    Mod(): antlr.TerminalNode | null;
    Mul(): antlr.TerminalNode | null;
    Sub(): antlr.TerminalNode | null;
    Equal(): antlr.TerminalNode | null;
    GreaterThan(): antlr.TerminalNode | null;
    GreaterThanOrEqual(): antlr.TerminalNode | null;
    LessThan(): antlr.TerminalNode | null;
    LessThanOrEqual(): antlr.TerminalNode | null;
    NotEqual(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UsingDirectiveContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Using(): antlr.TerminalNode;
    For(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    identifierPath(): IdentifierPathContext | null;
    Mul(): antlr.TerminalNode | null;
    typeName(): TypeNameContext | null;
    Global(): antlr.TerminalNode | null;
    LBrace(): antlr.TerminalNode | null;
    usingAliases(): UsingAliasesContext[];
    usingAliases(i: number): UsingAliasesContext | null;
    RBrace(): antlr.TerminalNode | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UsingAliasesContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifierPath(): IdentifierPathContext;
    As(): antlr.TerminalNode | null;
    userDefinableOperator(): UserDefinableOperatorContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class TypeNameContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    elementaryTypeName(): ElementaryTypeNameContext | null;
    functionTypeName(): FunctionTypeNameContext | null;
    mappingType(): MappingTypeContext | null;
    identifierPath(): IdentifierPathContext | null;
    typeName(): TypeNameContext | null;
    LBrack(): antlr.TerminalNode | null;
    RBrack(): antlr.TerminalNode | null;
    expression(): ExpressionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ElementaryTypeNameContext extends antlr.ParserRuleContext {
    allowAddressPayable: boolean;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number, allowAddressPayable: boolean);
    Address(): antlr.TerminalNode | null;
    Payable(): antlr.TerminalNode | null;
    Bool(): antlr.TerminalNode | null;
    String(): antlr.TerminalNode | null;
    Bytes(): antlr.TerminalNode | null;
    SignedIntegerType(): antlr.TerminalNode | null;
    UnsignedIntegerType(): antlr.TerminalNode | null;
    FixedBytes(): antlr.TerminalNode | null;
    Fixed(): antlr.TerminalNode | null;
    Ufixed(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class FunctionTypeNameContext extends antlr.ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    _arguments?: ParameterListContext;
    _returnParameters?: ParameterListContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Function(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode[];
    LParen(i: number): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode[];
    RParen(i: number): antlr.TerminalNode | null;
    visibility(): VisibilityContext[];
    visibility(i: number): VisibilityContext | null;
    stateMutability(): StateMutabilityContext[];
    stateMutability(i: number): StateMutabilityContext | null;
    Returns(): antlr.TerminalNode | null;
    parameterList(): ParameterListContext[];
    parameterList(i: number): ParameterListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class VariableDeclarationContext extends antlr.ParserRuleContext {
    _type_?: TypeNameContext;
    _location?: DataLocationContext;
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    dataLocation(): DataLocationContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class DataLocationContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Memory(): antlr.TerminalNode | null;
    Storage(): antlr.TerminalNode | null;
    Calldata(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExpressionContext): void;
}
export declare class UnaryPrefixOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext;
    Inc(): antlr.TerminalNode | null;
    Dec(): antlr.TerminalNode | null;
    Not(): antlr.TerminalNode | null;
    BitNot(): antlr.TerminalNode | null;
    Delete(): antlr.TerminalNode | null;
    Sub(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class PrimaryExpressionContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    identifier(): IdentifierContext | null;
    literal(): LiteralContext | null;
    literalWithSubDenomination(): LiteralWithSubDenominationContext | null;
    elementaryTypeName(): ElementaryTypeNameContext | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class OrderComparisonContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    LessThan(): antlr.TerminalNode | null;
    GreaterThan(): antlr.TerminalNode | null;
    LessThanOrEqual(): antlr.TerminalNode | null;
    GreaterThanOrEqual(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ConditionalContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Conditional(): antlr.TerminalNode;
    Colon(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class PayableConversionContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    Payable(): antlr.TerminalNode;
    callArgumentList(): CallArgumentListContext;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class AssignmentContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    assignOp(): AssignOpContext;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UnarySuffixOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext;
    Inc(): antlr.TerminalNode | null;
    Dec(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ShiftOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Shl(): antlr.TerminalNode | null;
    Sar(): antlr.TerminalNode | null;
    Shr(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class BitAndOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    BitAnd(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class FunctionCallContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext;
    callArgumentList(): CallArgumentListContext;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class IndexRangeAccessContext extends ExpressionContext {
    _startIndex?: ExpressionContext;
    _endIndex?: ExpressionContext;
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    LBrack(): antlr.TerminalNode;
    Colon(): antlr.TerminalNode;
    RBrack(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class IndexAccessContext extends ExpressionContext {
    _index?: ExpressionContext;
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    LBrack(): antlr.TerminalNode;
    RBrack(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class AddSubOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Add(): antlr.TerminalNode | null;
    Sub(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class BitOrOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    BitOr(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ExpOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Exp(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class AndOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    And(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class InlineArrayContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    inlineArrayExpression(): InlineArrayExpressionContext;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class OrOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Or(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class MemberAccessContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext;
    Period(): antlr.TerminalNode;
    identifier(): IdentifierContext | null;
    Address(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class MulDivModOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Mul(): antlr.TerminalNode | null;
    Div(): antlr.TerminalNode | null;
    Mod(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class FunctionCallOptionsContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext;
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    namedArgument(): NamedArgumentContext[];
    namedArgument(i: number): NamedArgumentContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class NewExprContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    New(): antlr.TerminalNode;
    typeName(): TypeNameContext;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class BitXorOperationContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    BitXor(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class TupleContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    tupleExpression(): TupleExpressionContext;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class EqualityComparisonContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Equal(): antlr.TerminalNode | null;
    NotEqual(): antlr.TerminalNode | null;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class MetaTypeContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    Type(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    typeName(): TypeNameContext;
    RParen(): antlr.TerminalNode;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class AssignOpContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Assign(): antlr.TerminalNode | null;
    AssignBitOr(): antlr.TerminalNode | null;
    AssignBitXor(): antlr.TerminalNode | null;
    AssignBitAnd(): antlr.TerminalNode | null;
    AssignShl(): antlr.TerminalNode | null;
    AssignSar(): antlr.TerminalNode | null;
    AssignShr(): antlr.TerminalNode | null;
    AssignAdd(): antlr.TerminalNode | null;
    AssignSub(): antlr.TerminalNode | null;
    AssignMul(): antlr.TerminalNode | null;
    AssignDiv(): antlr.TerminalNode | null;
    AssignMod(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class TupleExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class InlineArrayExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LBrack(): antlr.TerminalNode;
    RBrack(): antlr.TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class IdentifierContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Identifier(): antlr.TerminalNode | null;
    From(): antlr.TerminalNode | null;
    Error(): antlr.TerminalNode | null;
    Revert(): antlr.TerminalNode | null;
    Global(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class LiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    stringLiteral(): StringLiteralContext | null;
    numberLiteral(): NumberLiteralContext | null;
    booleanLiteral(): BooleanLiteralContext | null;
    hexStringLiteral(): HexStringLiteralContext | null;
    unicodeStringLiteral(): UnicodeStringLiteralContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class LiteralWithSubDenominationContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    numberLiteral(): NumberLiteralContext;
    SubDenomination(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class BooleanLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    True(): antlr.TerminalNode | null;
    False(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class StringLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    NonEmptyStringLiteral(): antlr.TerminalNode[];
    NonEmptyStringLiteral(i: number): antlr.TerminalNode | null;
    EmptyStringLiteral(): antlr.TerminalNode[];
    EmptyStringLiteral(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class HexStringLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    HexString(): antlr.TerminalNode[];
    HexString(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UnicodeStringLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    UnicodeStringLiteral(): antlr.TerminalNode[];
    UnicodeStringLiteral(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class NumberLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    DecimalNumber(): antlr.TerminalNode | null;
    HexNumber(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class BlockContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LBrace(): antlr.TerminalNode;
    RBrace(): antlr.TerminalNode;
    statement(): StatementContext[];
    statement(i: number): StatementContext | null;
    uncheckedBlock(): UncheckedBlockContext[];
    uncheckedBlock(i: number): UncheckedBlockContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class UncheckedBlockContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Unchecked(): antlr.TerminalNode;
    block(): BlockContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class StatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    block(): BlockContext | null;
    simpleStatement(): SimpleStatementContext | null;
    ifStatement(): IfStatementContext | null;
    forStatement(): ForStatementContext | null;
    whileStatement(): WhileStatementContext | null;
    doWhileStatement(): DoWhileStatementContext | null;
    continueStatement(): ContinueStatementContext | null;
    breakStatement(): BreakStatementContext | null;
    tryStatement(): TryStatementContext | null;
    returnStatement(): ReturnStatementContext | null;
    emitStatement(): EmitStatementContext | null;
    revertStatement(): RevertStatementContext | null;
    assemblyStatement(): AssemblyStatementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class SimpleStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    variableDeclarationStatement(): VariableDeclarationStatementContext | null;
    expressionStatement(): ExpressionStatementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class IfStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    If(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    expression(): ExpressionContext;
    RParen(): antlr.TerminalNode;
    statement(): StatementContext[];
    statement(i: number): StatementContext | null;
    Else(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ForStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    For(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    statement(): StatementContext;
    simpleStatement(): SimpleStatementContext | null;
    Semicolon(): antlr.TerminalNode[];
    Semicolon(i: number): antlr.TerminalNode | null;
    expressionStatement(): ExpressionStatementContext | null;
    expression(): ExpressionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class WhileStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    While(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    expression(): ExpressionContext;
    RParen(): antlr.TerminalNode;
    statement(): StatementContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class DoWhileStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Do(): antlr.TerminalNode;
    statement(): StatementContext;
    While(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    expression(): ExpressionContext;
    RParen(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ContinueStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Continue(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class BreakStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Break(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class TryStatementContext extends antlr.ParserRuleContext {
    _returnParameters?: ParameterListContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Try(): antlr.TerminalNode;
    expression(): ExpressionContext;
    block(): BlockContext;
    Returns(): antlr.TerminalNode | null;
    LParen(): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode | null;
    catchClause(): CatchClauseContext[];
    catchClause(i: number): CatchClauseContext | null;
    parameterList(): ParameterListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class CatchClauseContext extends antlr.ParserRuleContext {
    _arguments?: ParameterListContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Catch(): antlr.TerminalNode;
    block(): BlockContext;
    LParen(): antlr.TerminalNode | null;
    RParen(): antlr.TerminalNode | null;
    identifier(): IdentifierContext | null;
    parameterList(): ParameterListContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ReturnStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Return(): antlr.TerminalNode;
    Semicolon(): antlr.TerminalNode;
    expression(): ExpressionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class EmitStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Emit(): antlr.TerminalNode;
    expression(): ExpressionContext;
    callArgumentList(): CallArgumentListContext;
    Semicolon(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class RevertStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Revert(): antlr.TerminalNode;
    expression(): ExpressionContext;
    callArgumentList(): CallArgumentListContext;
    Semicolon(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class AssemblyStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Assembly(): antlr.TerminalNode;
    AssemblyLBrace(): antlr.TerminalNode;
    YulRBrace(): antlr.TerminalNode;
    AssemblyDialect(): antlr.TerminalNode | null;
    assemblyFlags(): AssemblyFlagsContext | null;
    yulStatement(): YulStatementContext[];
    yulStatement(i: number): YulStatementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class AssemblyFlagsContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    AssemblyBlockLParen(): antlr.TerminalNode;
    AssemblyFlagString(): antlr.TerminalNode[];
    AssemblyFlagString(i: number): antlr.TerminalNode | null;
    AssemblyBlockRParen(): antlr.TerminalNode;
    AssemblyBlockComma(): antlr.TerminalNode[];
    AssemblyBlockComma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class VariableDeclarationListContext extends antlr.ParserRuleContext {
    _variableDeclaration?: VariableDeclarationContext;
    _variableDeclarations: VariableDeclarationContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    variableDeclaration(): VariableDeclarationContext[];
    variableDeclaration(i: number): VariableDeclarationContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class VariableDeclarationTupleContext extends antlr.ParserRuleContext {
    _variableDeclaration?: VariableDeclarationContext;
    _variableDeclarations: VariableDeclarationContext[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LParen(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    variableDeclaration(): VariableDeclarationContext[];
    variableDeclaration(i: number): VariableDeclarationContext | null;
    Comma(): antlr.TerminalNode[];
    Comma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class VariableDeclarationStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Semicolon(): antlr.TerminalNode;
    variableDeclaration(): VariableDeclarationContext | null;
    variableDeclarationTuple(): VariableDeclarationTupleContext | null;
    Assign(): antlr.TerminalNode | null;
    expression(): ExpressionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class ExpressionStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    expression(): ExpressionContext;
    Semicolon(): antlr.TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class MappingTypeContext extends antlr.ParserRuleContext {
    _key?: MappingKeyTypeContext;
    _name?: IdentifierContext;
    _value?: TypeNameContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    Mapping(): antlr.TerminalNode;
    LParen(): antlr.TerminalNode;
    DoubleArrow(): antlr.TerminalNode;
    RParen(): antlr.TerminalNode;
    mappingKeyType(): MappingKeyTypeContext;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class MappingKeyTypeContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    elementaryTypeName(): ElementaryTypeNameContext | null;
    identifierPath(): IdentifierPathContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    yulBlock(): YulBlockContext | null;
    yulVariableDeclaration(): YulVariableDeclarationContext | null;
    yulAssignment(): YulAssignmentContext | null;
    yulFunctionCall(): YulFunctionCallContext | null;
    yulIfStatement(): YulIfStatementContext | null;
    yulForStatement(): YulForStatementContext | null;
    yulSwitchStatement(): YulSwitchStatementContext | null;
    YulLeave(): antlr.TerminalNode | null;
    YulBreak(): antlr.TerminalNode | null;
    YulContinue(): antlr.TerminalNode | null;
    yulFunctionDefinition(): YulFunctionDefinitionContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulBlockContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulLBrace(): antlr.TerminalNode;
    YulRBrace(): antlr.TerminalNode;
    yulStatement(): YulStatementContext[];
    yulStatement(i: number): YulStatementContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulVariableDeclarationContext extends antlr.ParserRuleContext {
    _YulIdentifier?: Token | null;
    _variables: antlr.Token[];
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulLet(): antlr.TerminalNode | null;
    YulIdentifier(): antlr.TerminalNode[];
    YulIdentifier(i: number): antlr.TerminalNode | null;
    YulAssign(): antlr.TerminalNode | null;
    yulExpression(): YulExpressionContext | null;
    YulComma(): antlr.TerminalNode[];
    YulComma(i: number): antlr.TerminalNode | null;
    yulFunctionCall(): YulFunctionCallContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulAssignmentContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    yulPath(): YulPathContext[];
    yulPath(i: number): YulPathContext | null;
    YulAssign(): antlr.TerminalNode;
    yulExpression(): YulExpressionContext | null;
    yulFunctionCall(): YulFunctionCallContext | null;
    YulComma(): antlr.TerminalNode[];
    YulComma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulIfStatementContext extends antlr.ParserRuleContext {
    _cond?: YulExpressionContext;
    _body?: YulBlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulIf(): antlr.TerminalNode;
    yulExpression(): YulExpressionContext;
    yulBlock(): YulBlockContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulForStatementContext extends antlr.ParserRuleContext {
    _init?: YulBlockContext;
    _cond?: YulExpressionContext;
    _post?: YulBlockContext;
    _body?: YulBlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulFor(): antlr.TerminalNode;
    yulBlock(): YulBlockContext[];
    yulBlock(i: number): YulBlockContext | null;
    yulExpression(): YulExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulSwitchCaseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulCase(): antlr.TerminalNode;
    yulLiteral(): YulLiteralContext;
    yulBlock(): YulBlockContext;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulSwitchStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulSwitch(): antlr.TerminalNode;
    yulExpression(): YulExpressionContext;
    YulDefault(): antlr.TerminalNode | null;
    yulBlock(): YulBlockContext | null;
    yulSwitchCase(): YulSwitchCaseContext[];
    yulSwitchCase(i: number): YulSwitchCaseContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulFunctionDefinitionContext extends antlr.ParserRuleContext {
    _YulIdentifier?: Token | null;
    _arguments: antlr.Token[];
    _returnParameters: antlr.Token[];
    _body?: YulBlockContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulFunction(): antlr.TerminalNode;
    YulIdentifier(): antlr.TerminalNode[];
    YulIdentifier(i: number): antlr.TerminalNode | null;
    YulLParen(): antlr.TerminalNode;
    YulRParen(): antlr.TerminalNode;
    yulBlock(): YulBlockContext;
    YulArrow(): antlr.TerminalNode | null;
    YulComma(): antlr.TerminalNode[];
    YulComma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulPathContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulIdentifier(): antlr.TerminalNode[];
    YulIdentifier(i: number): antlr.TerminalNode | null;
    YulPeriod(): antlr.TerminalNode[];
    YulPeriod(i: number): antlr.TerminalNode | null;
    YulEVMBuiltin(): antlr.TerminalNode[];
    YulEVMBuiltin(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulFunctionCallContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulLParen(): antlr.TerminalNode;
    YulRParen(): antlr.TerminalNode;
    YulIdentifier(): antlr.TerminalNode | null;
    YulEVMBuiltin(): antlr.TerminalNode | null;
    yulExpression(): YulExpressionContext[];
    yulExpression(i: number): YulExpressionContext | null;
    YulComma(): antlr.TerminalNode[];
    YulComma(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulBooleanContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulTrue(): antlr.TerminalNode | null;
    YulFalse(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    YulDecimalNumber(): antlr.TerminalNode | null;
    YulStringLiteral(): antlr.TerminalNode | null;
    YulHexNumber(): antlr.TerminalNode | null;
    yulBoolean(): YulBooleanContext | null;
    YulHexStringLiteral(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
export declare class YulExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    yulPath(): YulPathContext | null;
    yulFunctionCall(): YulFunctionCallContext | null;
    yulLiteral(): YulLiteralContext | null;
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result | null;
}
