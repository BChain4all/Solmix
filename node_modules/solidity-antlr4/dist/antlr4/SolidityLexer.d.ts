import * as antlr from "antlr4ng";
export declare class SolidityLexer extends antlr.Lexer {
    static readonly ReservedKeywords = 1;
    static readonly Abstract = 2;
    static readonly Address = 3;
    static readonly Anonymous = 4;
    static readonly As = 5;
    static readonly Assembly = 6;
    static readonly Bool = 7;
    static readonly Break = 8;
    static readonly Bytes = 9;
    static readonly Calldata = 10;
    static readonly Catch = 11;
    static readonly Constant = 12;
    static readonly Constructor = 13;
    static readonly Continue = 14;
    static readonly Contract = 15;
    static readonly Delete = 16;
    static readonly Do = 17;
    static readonly Else = 18;
    static readonly Emit = 19;
    static readonly Enum = 20;
    static readonly Error = 21;
    static readonly Event = 22;
    static readonly External = 23;
    static readonly Fallback = 24;
    static readonly False = 25;
    static readonly Fixed = 26;
    static readonly FixedBytes = 27;
    static readonly For = 28;
    static readonly From = 29;
    static readonly Function = 30;
    static readonly Global = 31;
    static readonly Hex = 32;
    static readonly If = 33;
    static readonly Immutable = 34;
    static readonly Import = 35;
    static readonly Indexed = 36;
    static readonly Interface = 37;
    static readonly Internal = 38;
    static readonly Is = 39;
    static readonly Library = 40;
    static readonly Mapping = 41;
    static readonly Memory = 42;
    static readonly Modifier = 43;
    static readonly New = 44;
    static readonly SubDenomination = 45;
    static readonly Override = 46;
    static readonly Payable = 47;
    static readonly Pragma = 48;
    static readonly Private = 49;
    static readonly Public = 50;
    static readonly Pure = 51;
    static readonly Receive = 52;
    static readonly Return = 53;
    static readonly Returns = 54;
    static readonly Revert = 55;
    static readonly SignedIntegerType = 56;
    static readonly Storage = 57;
    static readonly String = 58;
    static readonly Struct = 59;
    static readonly True = 60;
    static readonly Try = 61;
    static readonly Type = 62;
    static readonly Ufixed = 63;
    static readonly Unchecked = 64;
    static readonly Unicode = 65;
    static readonly UnsignedIntegerType = 66;
    static readonly Using = 67;
    static readonly View = 68;
    static readonly Virtual = 69;
    static readonly While = 70;
    static readonly LParen = 71;
    static readonly RParen = 72;
    static readonly LBrack = 73;
    static readonly RBrack = 74;
    static readonly LBrace = 75;
    static readonly RBrace = 76;
    static readonly Colon = 77;
    static readonly Semicolon = 78;
    static readonly Period = 79;
    static readonly Conditional = 80;
    static readonly DoubleArrow = 81;
    static readonly RightArrow = 82;
    static readonly Assign = 83;
    static readonly AssignBitOr = 84;
    static readonly AssignBitXor = 85;
    static readonly AssignBitAnd = 86;
    static readonly AssignShl = 87;
    static readonly AssignSar = 88;
    static readonly AssignShr = 89;
    static readonly AssignAdd = 90;
    static readonly AssignSub = 91;
    static readonly AssignMul = 92;
    static readonly AssignDiv = 93;
    static readonly AssignMod = 94;
    static readonly Comma = 95;
    static readonly Or = 96;
    static readonly And = 97;
    static readonly BitOr = 98;
    static readonly BitXor = 99;
    static readonly BitAnd = 100;
    static readonly Shl = 101;
    static readonly Sar = 102;
    static readonly Shr = 103;
    static readonly Add = 104;
    static readonly Sub = 105;
    static readonly Mul = 106;
    static readonly Div = 107;
    static readonly Mod = 108;
    static readonly Exp = 109;
    static readonly Equal = 110;
    static readonly NotEqual = 111;
    static readonly LessThan = 112;
    static readonly GreaterThan = 113;
    static readonly LessThanOrEqual = 114;
    static readonly GreaterThanOrEqual = 115;
    static readonly Not = 116;
    static readonly BitNot = 117;
    static readonly Inc = 118;
    static readonly Dec = 119;
    static readonly DoubleQuote = 120;
    static readonly SingleQuote = 121;
    static readonly NonEmptyStringLiteral = 122;
    static readonly EmptyStringLiteral = 123;
    static readonly UnicodeStringLiteral = 124;
    static readonly HexString = 125;
    static readonly HexNumber = 126;
    static readonly OctalNumber = 127;
    static readonly DecimalNumber = 128;
    static readonly DecimalNumberFollowedByIdentifier = 129;
    static readonly Identifier = 130;
    static readonly WS = 131;
    static readonly COMMENT = 132;
    static readonly LINE_COMMENT = 133;
    static readonly AssemblyDialect = 134;
    static readonly AssemblyLBrace = 135;
    static readonly AssemblyFlagString = 136;
    static readonly AssemblyBlockLParen = 137;
    static readonly AssemblyBlockRParen = 138;
    static readonly AssemblyBlockComma = 139;
    static readonly AssemblyBlockWS = 140;
    static readonly AssemblyBlockCOMMENT = 141;
    static readonly AssemblyBlockLINE_COMMENT = 142;
    static readonly YulBreak = 143;
    static readonly YulCase = 144;
    static readonly YulContinue = 145;
    static readonly YulDefault = 146;
    static readonly YulFalse = 147;
    static readonly YulFor = 148;
    static readonly YulFunction = 149;
    static readonly YulIf = 150;
    static readonly YulLeave = 151;
    static readonly YulLet = 152;
    static readonly YulSwitch = 153;
    static readonly YulTrue = 154;
    static readonly YulHex = 155;
    static readonly YulEVMBuiltin = 156;
    static readonly YulLBrace = 157;
    static readonly YulRBrace = 158;
    static readonly YulLParen = 159;
    static readonly YulRParen = 160;
    static readonly YulAssign = 161;
    static readonly YulPeriod = 162;
    static readonly YulComma = 163;
    static readonly YulArrow = 164;
    static readonly YulIdentifier = 165;
    static readonly YulHexNumber = 166;
    static readonly YulDecimalNumber = 167;
    static readonly YulStringLiteral = 168;
    static readonly YulHexStringLiteral = 169;
    static readonly YulWS = 170;
    static readonly YulCOMMENT = 171;
    static readonly YulLINE_COMMENT = 172;
    static readonly PragmaToken = 173;
    static readonly PragmaSemicolon = 174;
    static readonly PragmaWS = 175;
    static readonly PragmaCOMMENT = 176;
    static readonly PragmaLINE_COMMENT = 177;
    static readonly AssemblyBlockMode = 1;
    static readonly YulMode = 2;
    static readonly PragmaMode = 3;
    static readonly channelNames: readonly ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
    static readonly literalNames: readonly [null, null, "'abstract'", "'address'", "'anonymous'", "'as'", "'assembly'", "'bool'", null, "'bytes'", "'calldata'", "'catch'", "'constant'", "'constructor'", null, "'contract'", "'delete'", "'do'", "'else'", "'emit'", "'enum'", "'error'", "'event'", "'external'", "'fallback'", null, null, null, null, "'from'", null, "'global'", null, null, "'immutable'", "'import'", "'indexed'", "'interface'", "'internal'", "'is'", "'library'", "'mapping'", "'memory'", "'modifier'", "'new'", null, "'override'", "'payable'", "'pragma'", "'private'", "'public'", "'pure'", "'receive'", "'return'", "'returns'", "'revert'", null, "'storage'", "'string'", "'struct'", null, "'try'", "'type'", null, "'unchecked'", "'unicode'", null, "'using'", "'view'", "'virtual'", "'while'", null, null, "'['", "']'", null, null, "':'", null, null, "'?'", "'=>'", null, "'='", "'|='", "'^='", "'&='", "'<<='", "'>>='", "'>>>='", "'+='", "'-='", "'*='", "'/='", "'%='", null, "'||'", "'&&'", "'|'", "'^'", "'&'", "'<<'", "'>>'", "'>>>'", "'+'", "'-'", "'*'", "'/'", "'%'", "'**'", "'=='", "'!='", "'<'", "'>'", "'<='", "'>='", "'!'", "'~'", "'++'", "'--'", "'\"'", "'''", null, null, null, null, null, null, null, null, null, null, null, null, "'\"evmasm\"'", null, null, null, null, null, null, null, null, null, "'case'", null, "'default'", null, null, null, null, "'leave'", "'let'", "'switch'", null, null, null, null, null, null, null, "':='"];
    static readonly symbolicNames: readonly [null, "ReservedKeywords", "Abstract", "Address", "Anonymous", "As", "Assembly", "Bool", "Break", "Bytes", "Calldata", "Catch", "Constant", "Constructor", "Continue", "Contract", "Delete", "Do", "Else", "Emit", "Enum", "Error", "Event", "External", "Fallback", "False", "Fixed", "FixedBytes", "For", "From", "Function", "Global", "Hex", "If", "Immutable", "Import", "Indexed", "Interface", "Internal", "Is", "Library", "Mapping", "Memory", "Modifier", "New", "SubDenomination", "Override", "Payable", "Pragma", "Private", "Public", "Pure", "Receive", "Return", "Returns", "Revert", "SignedIntegerType", "Storage", "String", "Struct", "True", "Try", "Type", "Ufixed", "Unchecked", "Unicode", "UnsignedIntegerType", "Using", "View", "Virtual", "While", "LParen", "RParen", "LBrack", "RBrack", "LBrace", "RBrace", "Colon", "Semicolon", "Period", "Conditional", "DoubleArrow", "RightArrow", "Assign", "AssignBitOr", "AssignBitXor", "AssignBitAnd", "AssignShl", "AssignSar", "AssignShr", "AssignAdd", "AssignSub", "AssignMul", "AssignDiv", "AssignMod", "Comma", "Or", "And", "BitOr", "BitXor", "BitAnd", "Shl", "Sar", "Shr", "Add", "Sub", "Mul", "Div", "Mod", "Exp", "Equal", "NotEqual", "LessThan", "GreaterThan", "LessThanOrEqual", "GreaterThanOrEqual", "Not", "BitNot", "Inc", "Dec", "DoubleQuote", "SingleQuote", "NonEmptyStringLiteral", "EmptyStringLiteral", "UnicodeStringLiteral", "HexString", "HexNumber", "OctalNumber", "DecimalNumber", "DecimalNumberFollowedByIdentifier", "Identifier", "WS", "COMMENT", "LINE_COMMENT", "AssemblyDialect", "AssemblyLBrace", "AssemblyFlagString", "AssemblyBlockLParen", "AssemblyBlockRParen", "AssemblyBlockComma", "AssemblyBlockWS", "AssemblyBlockCOMMENT", "AssemblyBlockLINE_COMMENT", "YulBreak", "YulCase", "YulContinue", "YulDefault", "YulFalse", "YulFor", "YulFunction", "YulIf", "YulLeave", "YulLet", "YulSwitch", "YulTrue", "YulHex", "YulEVMBuiltin", "YulLBrace", "YulRBrace", "YulLParen", "YulRParen", "YulAssign", "YulPeriod", "YulComma", "YulArrow", "YulIdentifier", "YulHexNumber", "YulDecimalNumber", "YulStringLiteral", "YulHexStringLiteral", "YulWS", "YulCOMMENT", "YulLINE_COMMENT", "PragmaToken", "PragmaSemicolon", "PragmaWS", "PragmaCOMMENT", "PragmaLINE_COMMENT"];
    static readonly modeNames: readonly ["DEFAULT_MODE", "AssemblyBlockMode", "YulMode", "PragmaMode"];
    static readonly ruleNames: readonly ["ReservedKeywords", "Abstract", "Address", "Anonymous", "As", "Assembly", "Bool", "Break", "Bytes", "Calldata", "Catch", "Constant", "Constructor", "Continue", "Contract", "Delete", "Do", "Else", "Emit", "Enum", "Error", "Event", "External", "Fallback", "False", "Fixed", "FixedBytes", "For", "From", "Function", "Global", "Hex", "If", "Immutable", "Import", "Indexed", "Interface", "Internal", "Is", "Library", "Mapping", "Memory", "Modifier", "New", "SubDenomination", "Override", "Payable", "Pragma", "Private", "Public", "Pure", "Receive", "Return", "Returns", "Revert", "SignedIntegerType", "Storage", "String", "Struct", "True", "Try", "Type", "Ufixed", "Unchecked", "Unicode", "UnsignedIntegerType", "Using", "View", "Virtual", "While", "LParen", "RParen", "LBrack", "RBrack", "LBrace", "RBrace", "Colon", "Semicolon", "Period", "Conditional", "DoubleArrow", "RightArrow", "Assign", "AssignBitOr", "AssignBitXor", "AssignBitAnd", "AssignShl", "AssignSar", "AssignShr", "AssignAdd", "AssignSub", "AssignMul", "AssignDiv", "AssignMod", "Comma", "Or", "And", "BitOr", "BitXor", "BitAnd", "Shl", "Sar", "Shr", "Add", "Sub", "Mul", "Div", "Mod", "Exp", "Equal", "NotEqual", "LessThan", "GreaterThan", "LessThanOrEqual", "GreaterThanOrEqual", "Not", "BitNot", "Inc", "Dec", "DoubleQuote", "SingleQuote", "NonEmptyStringLiteral", "EmptyStringLiteral", "DoubleQuotedStringCharacter", "SingleQuotedStringCharacter", "SingleQuotedPrintable", "DoubleQuotedPrintable", "EscapeSequence", "UnicodeStringLiteral", "DoubleQuotedUnicodeStringCharacter", "SingleQuotedUnicodeStringCharacter", "HexString", "HexNumber", "HexDigits", "EvenHexDigits", "HexCharacter", "OctalNumber", "DecimalNumber", "DecimalDigits", "DecimalNumberFollowedByIdentifier", "Identifier", "IdentifierStart", "IdentifierPart", "WS", "COMMENT", "LINE_COMMENT", "AssemblyDialect", "AssemblyLBrace", "AssemblyFlagString", "AssemblyBlockLParen", "AssemblyBlockRParen", "AssemblyBlockComma", "AssemblyBlockWS", "AssemblyBlockCOMMENT", "AssemblyBlockLINE_COMMENT", "YulBreak", "YulCase", "YulContinue", "YulDefault", "YulFalse", "YulFor", "YulFunction", "YulIf", "YulLeave", "YulLet", "YulSwitch", "YulTrue", "YulHex", "YulEVMBuiltin", "YulLBrace", "YulRBrace", "YulLParen", "YulRParen", "YulAssign", "YulPeriod", "YulComma", "YulArrow", "YulIdentifier", "YulIdentifierStart", "YulIdentifierPart", "YulHexNumber", "YulDecimalNumber", "YulStringLiteral", "YulHexStringLiteral", "YulWS", "YulCOMMENT", "YulLINE_COMMENT", "PragmaToken", "PragmaSemicolon", "PragmaWS", "PragmaCOMMENT", "PragmaLINE_COMMENT"];
    constructor(input: antlr.CharStream);
    get grammarFileName(): string;
    get literalNames(): (string | null)[];
    get symbolicNames(): (string | null)[];
    get ruleNames(): string[];
    get serializedATN(): number[];
    get channelNames(): string[];
    get modeNames(): string[];
    static readonly _serializedATN: number[];
    private static __ATN;
    static get _ATN(): antlr.ATN;
    private static readonly vocabulary;
    get vocabulary(): antlr.Vocabulary;
    private static readonly decisionsToDFA;
}
