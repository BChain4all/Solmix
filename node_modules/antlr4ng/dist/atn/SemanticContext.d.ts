import { Recognizer } from "../Recognizer.js";
import { RuleContext } from "../RuleContext.js";
import { HashCode } from "../misc/HashCode.js";
import { HashSet } from "../misc/HashSet.js";
import { IComparable } from "../utils/helpers.js";
import { ATNSimulator } from "./ATNSimulator.js";
/**
 * A tree structure used to record the semantic context in which
 * an ATN configuration is valid.  It's either a single predicate,
 * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
 *
 * <p>I have scoped the {@link AND}, {@link OR}, and {@link SemanticContext.Predicate} subclasses of
 * {@link SemanticContext} within the scope of this outer class.</p>
 */
export declare abstract class SemanticContext implements IComparable {
    static andContext(a: SemanticContext | null, b: SemanticContext | null): SemanticContext | null;
    static orContext(a: SemanticContext | null, b: SemanticContext | null): SemanticContext | null;
    protected static filterPrecedencePredicates(set: HashSet<SemanticContext>): SemanticContext.PrecedencePredicate[];
    hashCode(): number;
    /**
     * Evaluate the precedence predicates for the context and reduce the result.
     *
     * @param _parser The parser instance.
     * @param _parserCallStack The current parser context object.
     * @returns The simplified semantic context after precedence predicates are
     * evaluated, which will be one of the following values.
     * <ul>
     * <li>{@link NONE}: if the predicate simplifies to {@code true} after
     * precedence predicates are evaluated.</li>
     * <li>{@code null}: if the predicate simplifies to {@code false} after
     * precedence predicates are evaluated.</li>
     * <li>{@code this}: if the semantic context is not changed as a result of
     * precedence predicate evaluation.</li>
     * <li>A non-{@code null} {@link SemanticContext}: the new simplified
     * semantic context after precedence predicates are evaluated.</li>
     * </ul>
     */
    evalPrecedence<T extends ATNSimulator>(_parser: Recognizer<T>, _parserCallStack: RuleContext | null): SemanticContext | null;
    /**
     * For context independent predicates, we evaluate them without a local
     * context (i.e., null context). That way, we can evaluate them without
     * having to create proper rule-specific context during prediction (as
     * opposed to the parser, which creates them naturally). In a practical
     * sense, this avoids a cast exception from RuleContext to myRuleContext.
     *
     * <p>For context dependent predicates, we must pass in a local context so that
     * references such as $arg evaluate properly as _localctx.arg. We only
     * capture context dependent predicates in the context in which we begin
     * prediction, so we passed in the outer context here in case of context
     * dependent predicate evaluation.</p>
     */
    abstract evaluate<T extends ATNSimulator>(parser: Recognizer<T>, parserCallStack: RuleContext): boolean;
    abstract equals(other: unknown): boolean;
    abstract updateHashCode(hash: HashCode): void;
}
export declare namespace SemanticContext {
    class Predicate extends SemanticContext {
        readonly ruleIndex: number;
        readonly predIndex: number;
        readonly isCtxDependent: boolean;
        constructor(ruleIndex?: number, predIndex?: number, isCtxDependent?: boolean);
        evaluate<T extends ATNSimulator>(parser: Recognizer<T>, outerContext: RuleContext): boolean;
        updateHashCode(hash: HashCode): void;
        equals(other: unknown): boolean;
        toString(): string;
    }
    class PrecedencePredicate extends SemanticContext {
        readonly precedence: number;
        constructor(precedence?: number);
        evaluate<T extends ATNSimulator>(parser: Recognizer<T>, outerContext: RuleContext): boolean;
        evalPrecedence(parser: Recognizer<ATNSimulator>, outerContext: RuleContext | null): SemanticContext | null;
        compareTo(other: PrecedencePredicate): number;
        updateHashCode(hash: HashCode): void;
        equals(other: unknown): boolean;
        toString(): string;
    }
    /**
     * The default {@link SemanticContext}, which is semantically equivalent to
     * a predicate of the form {@code {true}?}
     */
    const NONE: Predicate;
}
