import { RuleContext } from "../RuleContext.js";
import { PredictionContext } from "./PredictionContext.js";
import { SingletonPredictionContext } from "./SingletonPredictionContext.js";
import { HashMap } from "../misc/HashMap.js";
import { ATN } from "./ATN.js";
import { PredictionContextCache } from "./PredictionContextCache.js";
import { DoubleDict } from "../utils/DoubleDict.js";
/**
 * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
 * Return {@link EMPTY} if {@code outerContext} is empty or null.
 */
export declare const predictionContextFromRuleContext: (atn: ATN, outerContext: RuleContext) => PredictionContext;
export declare const getCachedPredictionContext: (context: PredictionContext, contextCache: PredictionContextCache, visited: HashMap<PredictionContext, PredictionContext>) => PredictionContext;
export declare const merge: (a: PredictionContext, b: PredictionContext, rootIsWildcard: boolean, mergeCache: DoubleDict<PredictionContext, PredictionContext, PredictionContext> | null) => PredictionContext;
/**
 * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
 * ones.
 */
export declare const combineCommonParents: (parents: Array<PredictionContext | null>) => void;
/**
 * Merge two {@link SingletonPredictionContext} instances.
 *
 * <p>Stack tops equal, parents merge is same; return left graph.<br>
 * <embed src="images/SingletonMerge_SameRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Same stack top, parents differ; merge parents giving array node, then
 * remainders of those graphs. A new root node is created to point to the
 * merged parents.<br>
 * <embed src="images/SingletonMerge_SameRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to same parent. Make array node for the
 * root where both element in the root point to the same (original)
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to different parents. Make array node for
 * the root where each element points to the corresponding original
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 * @param mergeCache tbd
 */
export declare const mergeSingletons: (a: SingletonPredictionContext, b: SingletonPredictionContext, rootIsWildcard: boolean, mergeCache: DoubleDict<PredictionContext, PredictionContext, PredictionContext> | null) => PredictionContext;
/**
 * Handle case where at least one of {@code a} or {@code b} is
 * {@link EMPTY}. In the following diagrams, the symbol {@code $} is used
 * to represent {@link EMPTY}.
 *
 * <h2>Local-Context Merges</h2>
 *
 * <p>These local-context merge operations are used when {@code rootIsWildcard}
 * is true.</p>
 *
 * <p>{@link EMPTY} is superset of any graph; return {@link EMPTY}.<br>
 * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p>{@link EMPTY} and anything is {@code //EMPTY}, so merged parent is
 * {@code //EMPTY}; return left graph.<br>
 * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
 *
 * <p>Special case of last merge if local context.<br>
 * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
 *
 * <h2>Full-Context Merges</h2>
 *
 * <p>These full-context merge operations are used when {@code rootIsWildcard}
 * is false.</p>
 *
 * <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
 *
 * <p>Must keep all contexts; {@link EMPTY} in array is a special value (and
 * null parent).<br>
 * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 */
export declare const mergeRoot: (a: SingletonPredictionContext, b: SingletonPredictionContext, rootIsWildcard: boolean) => PredictionContext | null;
export declare const getAllContextNodes: (context: PredictionContext | null, nodes: PredictionContext[], visited: HashMap<PredictionContext, PredictionContext> | null) => PredictionContext[];
