import { Lexer } from "../Lexer.js";
import { ATN } from "./ATN.js";
import { ATNSimulator } from "./ATNSimulator.js";
import { DFAState } from "../dfa/DFAState.js";
import { LexerATNConfig } from "./LexerATNConfig.js";
import { LexerActionExecutor } from "./LexerActionExecutor.js";
import { DFA } from "../dfa/DFA.js";
import { PredictionContextCache } from "./PredictionContextCache.js";
import { CharStream } from "../CharStream.js";
import { ATNConfigSet } from "./ATNConfigSet.js";
import { Transition } from "./Transition.js";
import { ATNState } from "./ATNState.js";
export declare class LexerATNSimulator extends ATNSimulator {
    static readonly MIN_DFA_EDGE = 0;
    static readonly MAX_DFA_EDGE = 127;
    static debug: boolean;
    private static dfa_debug;
    readonly decisionToDFA: DFA[];
    readonly recog: Lexer | null;
    /**
     * The current token's starting index into the character stream.
     *  Shared across DFA to ATN simulation in case the ATN fails and the
     *  DFA did not have a previous accept state. In this case, we use the
     *  ATN-generated exception object.
     */
    startIndex: number;
    /** line number 1..n within the input */
    line: number;
    /** The index of the character relative to the beginning of the line 0..n-1 */
    column: number;
    mode: number;
    /** Used during DFA/ATN exec to record the most recent accept configuration info */
    protected readonly prevAccept: LexerATNSimulator.SimState;
    /**
     * When we hit an accept state in either the DFA or the ATN, we
     * have to notify the character stream to start buffering characters
     * via {@link IntStream//mark} and record the current state. The current sim state
     * includes the current index into the input, the current line,
     * and current character position in that line. Note that the Lexer is
     * tracking the starting line and characterization of the token. These
     * variables track the "state" of the simulator when it hits an accept state.
     *
     * <p>We track these variables separately for the DFA and ATN simulation
     * because the DFA simulation often has to fail over to the ATN
     * simulation. If the ATN simulation fails, we need the DFA to fall
     * back to its previously accepted state, if any. If the ATN succeeds,
     * then the ATN does the accept and the DFA simulator that invoked it
     * can simply return the predicted token type.</p>
     */
    constructor(recog: Lexer | null, atn: ATN, decisionToDFA: DFA[], sharedContextCache: PredictionContextCache | null);
    copyState(simulator: LexerATNSimulator): void;
    match(input: CharStream, mode: number): number;
    reset(): void;
    getDFA(mode: number): DFA;
    getText(input: CharStream): string;
    consume(input: CharStream): void;
    getTokenName(tt: number): string;
    clearDFA(): void;
    protected matchATN(input: CharStream): number;
    protected execATN(input: CharStream, ds0: DFAState): number;
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns {@code null}.
     *
     * @param s The current DFA state
     * @param t The next input symbol
     * @returns The existing target DFA state for the given input symbol
     * {@code t}, or {@code null} if the target state for this edge is not
     * already cached
     */
    protected getExistingTargetState(s: DFAState, t: number): DFAState | null;
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param input The input stream
     * @param s The current DFA state
     * @param t The next input symbol
     *
     * @returns The computed target DFA state for the given input symbol
     * {@code t}. If {@code t} does not lead to a valid DFA state, this method
     * returns {@link ERROR}.
     */
    protected computeTargetState(input: CharStream, s: DFAState, t: number): DFAState;
    protected failOrAccept(prevAccept: LexerATNSimulator.SimState, input: CharStream, reach: ATNConfigSet, t: number): number;
    /**
     * Given a starting configuration set, figure out all ATN configurations
     * we can reach upon input {@code t}. Parameter {@code reach} is a return
     * parameter.
     */
    protected getReachableConfigSet(input: CharStream, closure: ATNConfigSet, reach: ATNConfigSet, t: number): void;
    protected accept(input: CharStream, lexerActionExecutor: LexerActionExecutor | null, startIndex: number, index: number, line: number, charPos: number): void;
    protected getReachableTarget(trans: Transition, t: number): ATNState | null;
    protected computeStartState(input: CharStream, p: ATNState): ATNConfigSet;
    /**
     * Since the alternatives within any lexer decision are ordered by
     * preference, this method stops pursuing the closure as soon as an accept
     * state is reached. After the first accept state is reached by depth-first
     * search from {@code config}, all other (potentially reachable) states for
     * this rule would have a lower priority.
     *
     * @returns {boolean} {@code true} if an accept state is reached, otherwise
     * {@code false}.
     */
    protected closure(input: CharStream, config: LexerATNConfig, configs: ATNConfigSet, currentAltReachedAcceptState: boolean, speculative: boolean, treatEofAsEpsilon: boolean): boolean;
    protected getEpsilonTarget(input: CharStream, config: LexerATNConfig, trans: Transition, configs: ATNConfigSet, speculative: boolean, treatEofAsEpsilon: boolean): LexerATNConfig | null;
    /**
     * Evaluate a predicate specified in the lexer.
     *
     * <p>If {@code speculative} is {@code true}, this method was called before
     * {@link consume} for the matched character. This method should call
     * {@link consume} before evaluating the predicate to ensure position
     * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
     * and {@link Lexer}, properly reflect the current
     * lexer state. This method should restore {@code input} and the simulator
     * to the original state before returning (i.e. undo the actions made by the
     * call to {@link consume}.</p>
     *
     * @param input The input stream.
     * @param ruleIndex The rule containing the predicate.
     * @param predIndex The index of the predicate within the rule.
     * @param speculative {@code true} if the current index in {@code input} is
     * one character before the predicate's location.
     *
     * @returns `true` if the specified predicate evaluates to
     * {@code true}.
     */
    protected evaluatePredicate(input: CharStream, ruleIndex: number, predIndex: number, speculative: boolean): boolean;
    protected captureSimState(settings: LexerATNSimulator.SimState, input: CharStream, dfaState: DFAState | null): void;
    protected addDFAEdge(from_: DFAState, tk: number, to: DFAState | null, configs?: ATNConfigSet | null): DFAState;
    /**
     * Add a new DFA state if there isn't one with this set of
     * configurations already. This method also detects the first
     * configuration containing an ATN rule stop state. Later, when
     * traversing the DFA, we will know which rule to accept.
     */
    protected addDFAState(configs: ATNConfigSet): DFAState;
}
export declare namespace LexerATNSimulator {
    /**
     * When we hit an accept state in either the DFA or the ATN, we
     *  have to notify the character stream to start buffering characters
     *  via {@link IntStream#mark} and record the current state. The current sim state
     *  includes the current index into the input, the current line,
     *  and current character position in that line. Note that the Lexer is
     *  tracking the starting line and characterization of the token. These
     *  variables track the "state" of the simulator when it hits an accept state.
     *
     *  <p>We track these variables separately for the DFA and ATN simulation
     *  because the DFA simulation often has to fail over to the ATN
     *  simulation. If the ATN simulation fails, we need the DFA to fall
     *  back to its previously accepted state, if any. If the ATN succeeds,
     *  then the ATN does the accept and the DFA simulator that invoked it
     *  can simply return the predicted token type.</p>
     */
    class SimState {
        index: number;
        line: number;
        column: number;
        dfaState: DFAState | null;
        reset(): void;
    }
}
