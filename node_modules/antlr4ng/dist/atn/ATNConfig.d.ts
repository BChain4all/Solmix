import { SemanticContext } from "./SemanticContext.js";
import { HashCode } from "../misc/HashCode.js";
import { ATNState } from "./ATNState.js";
import { PredictionContext } from "./PredictionContext.js";
import { Recognizer } from "../Recognizer.js";
import { ATNSimulator } from "./ATNSimulator.js";
export interface IATNConfigParameters {
    state?: ATNState | null;
    alt?: number | null;
    context?: PredictionContext | null;
    semanticContext?: SemanticContext | null;
    reachesIntoOuterContext?: number | null;
    precedenceFilterSuppressed?: number;
}
export interface ICheckedConfigParameters {
    state: ATNState | null;
    alt: number | null;
    context: PredictionContext | null;
    semanticContext: SemanticContext | null;
    reachesIntoOuterContext: number | null;
    precedenceFilterSuppressed?: boolean;
}
export declare class ATNConfig {
    /** The ATN state associated with this configuration */
    readonly state: ATNState;
    /** What alt (or lexer rule) is predicted by this configuration */
    readonly alt: number;
    /**
     * The stack of invoking states leading to the rule/states associated
     *  with this config.  We track only those contexts pushed during
     *  execution of the ATN simulator.
     */
    context: PredictionContext | null;
    /**
     * We cannot execute predicates dependent upon local context unless
     * we know for sure we are in the correct context. Because there is
     * no way to do this efficiently, we simply cannot evaluate
     * dependent predicates unless we are in the rule that initially
     * invokes the ATN simulator.
     *
     * closure() tracks the depth of how far we dip into the outer context:
     * depth &gt; 0.  Note that it may not be totally accurate depth since I
     * don't ever decrement. TODO: make it a boolean then</p>
     */
    reachesIntoOuterContext: number;
    precedenceFilterSuppressed: boolean;
    readonly semanticContext: SemanticContext;
    /**
     * @param {object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
     * The syntactic context is a graph-structured stack node whose
     * path(s) to the root is the rule invocation(s)
     * chain used to arrive at the state.  The semantic context is
     * the tree of semantic predicates encountered before reaching
     * an ATN state
     */
    constructor(params: IATNConfigParameters, config: ATNConfig | null);
    hashCode(): number;
    updateHashCode(hash: HashCode): void;
    /**
     * An ATN configuration is equal to another if both have
     * the same state, they predict the same alternative, and
     * syntactic/semantic contexts are the same
     */
    equals(other: unknown): boolean;
    hashCodeForConfigSet(): number;
    equalsForConfigSet(other: unknown): boolean;
    toString(_recog?: Recognizer<ATNSimulator> | null, showAlt?: boolean): string;
    private checkContext;
}
