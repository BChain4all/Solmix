import { RuleContext } from "./RuleContext.js";
import { Interval } from "./misc/Interval.js";
import { Token } from "./Token.js";
import { RecognitionException } from "./RecognitionException.js";
import { ParseTreeListener } from "./tree/ParseTreeListener.js";
import { ParseTree } from "./tree/ParseTree.js";
import { TerminalNode } from "./tree/TerminalNode.js";
import { ErrorNode } from "./tree/ErrorNode.js";
/**
 * A rule invocation record for parsing.
 *
 *  Contains all of the information about the current rule not stored in the
 *  RuleContext. It handles parse tree children list, Any ATN state
 *  tracing, and the default values available for rule indications:
 *  start, stop, rule index, current alt number, current
 *  ATN state.
 *
 *  Subclasses made for each rule and grammar track the parameters,
 *  return values, locals, and labels specific to that rule. These
 *  are the objects that are returned from rules.
 *
 *  Note text is not an actual field of a rule return value; it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
export declare class ParserRuleContext extends RuleContext {
    static readonly EMPTY: ParserRuleContext;
    start: Token | null;
    stop: Token | null;
    /**
     * The exception that forced this rule to return. If the rule successfully
     * completed, this is {@code null}.
     */
    exception: RecognitionException | null;
    constructor();
    constructor(parent: ParserRuleContext | null, invokingStateNumber: number);
    get parent(): ParserRuleContext | null;
    set parent(parent: ParserRuleContext | null);
    copyFrom(ctx: ParserRuleContext): void;
    enterRule(_listener: ParseTreeListener): void;
    exitRule(_listener: ParseTreeListener): void;
    /**
     * Add a parse tree node to this as a child.  Works for
     *  internal and leaf nodes. Does not set parent link;
     *  other add methods must do that. Other addChild methods
     *  call this.
     *
     *  We cannot set the parent pointer of the incoming node
     *  because the existing interfaces do not have a setParent()
     *  method and I don't want to break backward compatibility for this.
     */
    addAnyChild<T extends ParseTree>(t: T): T;
    addChild(child: RuleContext): RuleContext;
    /**
     * Used by enterOuterAlt to toss out a RuleContext previously added as
     * we entered a rule. If we have // label, we will need to remove
     * generic ruleContext object.
     */
    removeLastChild(): void;
    addTokenNode(token: Token): TerminalNode;
    /**
     * Add a child to this node based upon badToken.  It
     *  creates a ErrorNode rather than using
     *  {@link Parser#createErrorNode(ParserRuleContext, Token)}. I'm leaving this
     *  in for compatibility but the parser doesn't use this anymore.
     *
     * @deprecated
     */
    addErrorNode(errorNode: ErrorNode): ErrorNode;
    getChild(i: number): RuleContext | null;
    getChild<T extends ParseTree>(i: number, type: new (...args: unknown[]) => T): T | null;
    getToken(ttype: number, i: number): TerminalNode | null;
    getTokens(ttype: number): TerminalNode[];
    getRuleContext<T extends ParserRuleContext, Args extends unknown[]>(index: number, ctxType: new (...args: Args) => T): T | null;
    getRuleContexts<T extends ParserRuleContext, Args extends unknown[]>(ctxType: new (...args: Args) => T): T[];
    getChildCount(): number;
    getSourceInterval(): Interval;
}
