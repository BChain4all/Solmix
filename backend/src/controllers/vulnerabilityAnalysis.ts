import { Request, Response } from "express";
import { SLITHER_CONTAINER_NAME, SLITHER_SC_PATH } from "../config/env";
import dockerode from "dockerode";

export const vulnerabilityAnalysis = async (req: Request, res: Response) => {
    const docker = new dockerode();

    try {
        // List containers and find or create the Slither container
        const containers = await docker.listContainers();
        let container = containers.find(
            (c: any) =>
                c.Names &&
                c.Names.some(
                    (name: string) => name === `/${SLITHER_CONTAINER_NAME}`
                )
        );

        let containerId = container ? container.Id : "null";

        if (containerId === "null") {
            const createdContainer = await docker.createContainer({
                Image: "trailofbits/eth-security-toolbox",
                name: SLITHER_CONTAINER_NAME,
                Tty: true,
            });
            await createdContainer.start();
            containerId = createdContainer.id;
        }

        // Validate Solidity code
        const { solidityCode } = req.body;
        if (
            !solidityCode ||
            typeof solidityCode !== "string" ||
            solidityCode.trim().length === 0
        ) {
            res.status(400).json({ error: "Invalid Solidity code provided" });
            return;
        }
        if (
            !solidityCode.includes("pragma solidity") ||
            !solidityCode.includes("contract")
        ) {
            res.status(400).json({
                error: "Invalid Solidity code: must contain 'pragma solidity' and 'contract' declarations",
            });
            return;
        }

        // Helper to run a command in the container and get output
        async function execInContainer(cmd: string) {
            return new Promise<{ stdout: string; stderr: string }>(
                (resolve, reject) => {
                    docker.getContainer(containerId).exec(
                        {
                            AttachStdout: true,
                            AttachStderr: true,
                            Cmd: ["/bin/sh", "-c", cmd],
                        },
                        (err: any, exec: any) => {
                            if (err) return reject(err);
                            exec.start((startErr: any, stream: any) => {
                                if (startErr) return reject(startErr);
                                let stdout = "";
                                let stderr = "";
                                stream.on("data", (chunk: Buffer) => {
                                    stdout += chunk.toString();
                                });
                                stream.on("end", () =>
                                    resolve({ stdout, stderr })
                                );
                                stream.on("error", (e: any) => reject(e));
                            });
                        }
                    );
                }
            );
        }

        // Ensure that the SLITHER_SC_PATH directory exists in the container
        await execInContainer(`mkdir -p ${SLITHER_SC_PATH}`);

        // Extract pragma version
        function getPragma(solidityCode: string): string | null {
            const pattern = /(pragma solidity ).{0,2}(\d\.\d+\.\d+)/;
            const match = solidityCode.match(pattern);
            if (!match || !match[2]) return null;
            let pragma = match[2];
            const parts = pragma.split(".");
            if (parseInt(parts[1], 10) === 4 && parseInt(parts[2], 10) < 11) {
                pragma = "0.4.11";
            }
            return pragma;
        }
        const pragmaVersion = getPragma(solidityCode);
        if (!pragmaVersion) {
            res.status(400).json({
                error: "Solidity code must contain a valid pragma version declaration",
            });
            return;
        }

        // Save the Solidity code to a file in the container with timestamp
        const now = new Date();
        const pad = (n: number) => n.toString().padStart(2, "0");
        const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
        const solFileName = `contract_${timestamp}.sol`;
        const analysisFileName = `analysis_${timestamp}.json`;
        const solFilePath = `${SLITHER_SC_PATH}/${solFileName}`;
        const analysisFilePath = `${SLITHER_SC_PATH}/${analysisFileName}`;

        await execInContainer(
            `echo "${solidityCode.replace(/"/g, '\\"')}" > ${solFilePath}`
        );

        // Prepare commands to run inside the container
        const commands: string[] = [
            `solc-select install ${pragmaVersion}`,
            `solc-select use ${pragmaVersion}`,
        ];

        const nodeModulesCheck = `test -d ${SLITHER_SC_PATH}/node_modules && echo "exists" || echo "not_exists"`;
        console.log(nodeModulesCheck);

        // Check if node_modules exists in the container
        const { stdout: stdoutModule, stderr: stderrModule } = await execInContainer(
            nodeModulesCheck
        );

        if (stdoutModule.includes("non_exists")) {
            commands.push(
                `npm install --prefix ${SLITHER_SC_PATH} @openzeppelin/contracts@4.9.5`,
                `mv ${SLITHER_SC_PATH}/node_modules/@openzeppelin ${SLITHER_SC_PATH}`
            );
        }

        commands.push(`slither ${solFilePath} --json -`);
        console.log(`slither ${solFilePath} --json -`);
        // commands.push(`cat ${analysisFilePath}`);


        // Execute each command in sequence, saving only the last stdout
        let lastStdout = "";
        let lastStderr = "";
        for (const cmd of commands) {
            const { stdout, stderr } = await execInContainer(cmd);
            // Add a delay to allow the server more time to process the command
            // await new Promise((resolve) => setTimeout(resolve, 2000));
            lastStdout = stdout;
            lastStderr = stderr;
            console.log("Command: ", cmd);
            console.log("Slither raw output:", lastStdout);
            console.log("Slither stderr output:", lastStderr);
        }


        if (lastStderr) {
            res.status(500).json({
                error: "Error running analysis",
                details: lastStderr,
            });
            return;
        }

        let analysisJson;

        // Clean up the output
        lastStdout = lastStdout.replace(
            "\u0001\u0000\u0000\u0000\u0000\u0000\u0005M",
            ""
        );
        lastStdout = lastStdout.replace(/\\"/g, '"');
        lastStdout = lastStdout.replace(/\\n/g, "");
        console.log("Slither raw output:", lastStdout);
        console.log("Slither stderr output:", lastStderr);

        try {
            analysisJson = JSON.parse(lastStdout);
        } catch (e) {
            res.status(500).json({
          error: "Failed to parse analysis output as JSON",
          details: (e as Error).message,
          rawOutput: lastStdout,
            });
            return;
        }
        res.json({ containerId, analysis: analysisJson });
    } catch (err: any) {
        console.error("Error in vulnerabilityAnalysis:", err);
        res.status(500).json({
            error: "Internal Server Error",
            details: err.message,
        });
    }
};
