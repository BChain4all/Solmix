import { Request, Response } from "express";
import { SLITHER_CONTAINER_NAME, SLITHER_SC_PATH } from "../config/env";
import dockerode from "dockerode";

interface AnalysisResponse {
    error: string | null;
    compilerError: string[] | null;
    compilerWarn: string[] | null;
    details: any;
    analysis: any;
}

export const vulnerabilityAnalysis = async (req: Request, res: Response) => {
    const docker = new dockerode();

    // Initialize uniform response structure
    const response: AnalysisResponse = {
        error: null,
        compilerError: null,
        compilerWarn: null,
        details: null,
        analysis: null,
    };

    try {
        // List containers and find or create the Slither container
        const containers = await docker.listContainers();
        let container = containers.find(
            (c: any) =>
                c.Names &&
                c.Names.some(
                    (name: string) => name === `/${SLITHER_CONTAINER_NAME}`
                )
        );

        let containerId = container ? container.Id : "null";

        if (containerId === "null") {
            const createdContainer = await docker.createContainer({
                Image: "trailofbits/eth-security-toolbox",
                name: SLITHER_CONTAINER_NAME,
                Tty: true,
            });
            await createdContainer.start();
            containerId = createdContainer.id;
        }

        // Validate Solidity code
        const { solidityCode } = req.body;
        if (
            !solidityCode ||
            typeof solidityCode !== "string" ||
            solidityCode.trim().length === 0
        ) {
            response.error = "Invalid Solidity code provided";
            response.details =
                "Solidity code is required and must be a non-empty string";
            return res.status(400).json(response);
        }

        if (
            !solidityCode.includes("pragma solidity") ||
            !solidityCode.includes("contract")
        ) {
            response.error = "Invalid Solidity code format";
            response.details =
                "Solidity code must contain 'pragma solidity' and 'contract' declarations";
            return res.status(400).json(response);
        }

        // Helper to run a command in the container and get output
        async function execInContainer(
            cmd: string
        ): Promise<{ stdout: string; stderr: string }> {
            return new Promise<{ stdout: string; stderr: string }>(
                (resolve, reject) => {
                    docker.getContainer(containerId).exec(
                        {
                            AttachStdout: true,
                            AttachStderr: true,
                            Cmd: ["/bin/sh", "-c", cmd],
                        },
                        (err: any, exec: any) => {
                            if (err) return reject(err);
                            exec.start((startErr: any, stream: any) => {
                                if (startErr) return reject(startErr);
                                let stdout = "";
                                let stderr = "";
                                stream.on("data", (chunk: Buffer) => {
                                    stdout += chunk.toString();
                                });
                                stream.on("end", () =>
                                    resolve({ stdout, stderr })
                                );
                                stream.on("error", (e: any) => reject(e));
                            });
                        }
                    );
                }
            );
        }

        // Ensure that the SLITHER_SC_PATH directory exists in the container
        await execInContainer(`mkdir -p ${SLITHER_SC_PATH}`);

        // Extract pragma version
        function getPragma(solidityCode: string): string | null {
            const pattern = /(pragma solidity ).{0,2}(\d\.\d+\.\d+)/;
            const match = solidityCode.match(pattern);
            if (!match || !match[2]) return null;
            let pragma = match[2];
            const parts = pragma.split(".");
            if (parseInt(parts[1], 10) === 4 && parseInt(parts[2], 10) < 11) {
                pragma = "0.4.11";
            }
            return pragma;
        }

        const pragmaVersion = getPragma(solidityCode);
        if (!pragmaVersion) {
            response.error = "Invalid pragma version";
            response.details =
                "Solidity code must contain a valid pragma version declaration";
            return res.status(400).json(response);
        }

        // Save the Solidity code to a file in the container with timestamp
        const now = new Date();
        const pad = (n: number) => n.toString().padStart(2, "0");
        const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
        const solFileName = `contract_${timestamp}.sol`;
        const analysisFileName = `analysis_${timestamp}.json`;
        const solFilePath = `${SLITHER_SC_PATH}/${solFileName}`;
        const analysisFilePath = `${SLITHER_SC_PATH}/${analysisFileName}`;

        await execInContainer(
            `echo "${solidityCode.replace(/"/g, '\\"')}" > ${solFilePath}`
        );

        // Prepare commands to run inside the container
        const commands: string[] = [
            `solc-select install ${pragmaVersion}`,
            `solc-select use ${pragmaVersion}`,
        ];

        const nodeModulesCheck = `test -d ${SLITHER_SC_PATH}/node_modules && echo "exists" || echo "not_exists"`;
        console.log(nodeModulesCheck);

        // Check if node_modules exists in the container
        const { stdout: stdoutModule, stderr: stderrModule } =
            await execInContainer(nodeModulesCheck);
        console.log(stdoutModule);

        if (stdoutModule.includes("not_exists")) {
            commands.push(
                `npm install --prefix ${SLITHER_SC_PATH} @openzeppelin/contracts`,
                `mv ${SLITHER_SC_PATH}/node_modules/@openzeppelin ${SLITHER_SC_PATH}`
            );
        }

        commands.push(`cd ${SLITHER_SC_PATH} && slither ${solFileName}`);

        // Execute each command in sequence, saving only the last stdout
        let lastStdout = "";
        let lastStderr = "";
        for (const cmd of commands) {
            const { stdout, stderr } = await execInContainer(cmd);
            lastStdout = stdout;
            lastStderr = stderr;
            console.log("-----------------------------\nCommand: ", cmd);
            console.log("Slither raw output:", lastStdout);
        }

        // Parse compiler warnings and errors from initial compilation
        if (lastStdout) {
            const errorLines = lastStdout.match(/Error:[\s\S]*?\^\n/g);
            const warnLines = lastStdout.match(/Warning:.*(?=\n|$)/g);

            console.log("Extracted error lines:", errorLines);
            console.log("Extracted warning lines:", warnLines);

            response.compilerError = errorLines;
            response.compilerWarn = warnLines;

            if (errorLines && errorLines.length > 0) {
                response.error = "Compilation failed";
                response.details = "Solidity code has compilation errors";
                return res.status(400).json(response);
            }
        }

        // Run Slither analysis with JSON output
        const { stdout: stdoutVulRaw, stderr: stderrVul } =
            await execInContainer(
                `cd ${SLITHER_SC_PATH} && slither ${solFileName} --json -`
            );

        // Clean up the JSON output by removing control characters
        let stdoutVul = stdoutVulRaw
            .replace(/\u0001\u0000\u0000\u0000\u0000\u0000\u0005M/g, "")
            .replace(/\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0019/g, "")
            .replace(/\u0001\u0000\u0000\u0000\u0000\u0000\u0000W/g, "");

        console.log("Slither JSON raw output:", stdoutVul);

        if (!stdoutVul || stdoutVul.includes('"success": false')) {
            response.error = "Analysis execution failed";
            let errorDetails;
            try {
                errorDetails = JSON.parse(stdoutVul);
            } catch {
                errorDetails = { rawOutput: stdoutVul, stderr: stderrVul };
            }
            response.details = errorDetails;
            return res.status(500).json(response);
        }

        // Parse the analysis results
        try {
            const analysisJson = JSON.parse(stdoutVul);
            response.analysis = analysisJson;
            response.details = {
                containerId: containerId,
                timestamp: timestamp,
                pragmaVersion: pragmaVersion,
                fileName: solFileName,
            };
        } catch (parseError) {
            response.error = "Failed to parse analysis results";
            response.details = {
                parseError: (parseError as Error).message,
                rawOutput: stdoutVul,
            };
            return res.status(500).json(response);
        }

        // Return successful analysis
        return res.status(200).json(response);
    } catch (err: any) {
        console.error("Error in vulnerabilityAnalysis:", err);
        response.error = "Internal server error";
        response.details = {
            message: err.message,
            stack:
                process.env.NODE_ENV === "development" ? err.stack : undefined,
        };
        return res.status(500).json(response);
    }
};
